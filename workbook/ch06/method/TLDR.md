
## Methodical Evolution: A View on Computing's Enduring Rituals

Software methodology is the disciplined approach to creating software, balancing structured processes
with creative problem-solving. It transforms abstract cognitive work into repeatable and improvable
workflows.


### The Historical Journey

The early days of computing lacked formal methodologies, leading to the "software crisis" of the 1960s,
marked by budget overruns, delays, and low-quality software. This highlighted the need for a more disciplined
approach to software development.

The Waterfall model, often attributed to Winston Royce's 1970 paper,[^royce] introduced a sequential, phase-based
approach to software development. While influential, its rigidity in handling changing requirements
led to the exploration of iterative methods.

[^royce]: Royce, W. W. (1987). *Managing the development of large software systems: Concepts and techniques.*
In Proceedings of the 9th International Conference on Software Engineering (ICSE ’87) (pp. 328–338).
IEEE Computer Society Press.
https://dl.acm.org/doi/10.5555/41765.41801

The 1980s saw the rise of iterative models like Barry Boehm's Spiral model, which emphasised risk-driven
cycles. Rapid Application Development (RAD) also emerged, focusing on rapid prototyping and user feedback
to accelerate development.

The Agile movement, formalised by the Agile Manifesto in 2001 at the Snowbird retreat, prioritised individuals
and interactions, working software, customer collaboration, and responding to change. This marked a shift towards
more flexible and people-centric development.


### Core Concepts and Applications

- *Waterfall:* Emphasizes upfront planning and sequential execution, suitable for projects with stable requirements.[5]
- *Agile:* Focuses on iterative development, collaboration, and flexibility to adapt to changing needs.[6, 53, 59, 60, 61]


#### Methodologies and Their Focus

| Methodology | Focus | Scope | Key Artifacts | Example Tools |
|--|--|--|--|--|
| Waterfall | Predictive Planning | Large Projects | Gantt Charts, SDD | MS Project |
| Agile | Adaptive Delivery | Team-Level | Sprint Backlogs, User Stories | Jira |
| DevOps | Deployment Continuity | Organization | CI/CD Pipelines | Jenkins, GitLab CI |
| TDD | Code Correctness | Module | Unit Tests | JUnit |
| Pair Programming | Knowledge Sharing | Individual | Shared Codebases | VS Live Share |
| Design Thinking | User Empathy | Product | Personas, Miro Boards | Miro |
| CRISP-DM | Data Workflows | Analytics | Model Cards | MLflow |
| ITIL | Service Management | Enterprise | SLAs | ServiceNow |
| Six Sigma | Defect Reduction | Processes | Control Charts | Minitab |
| Shape Up | Cycle Management | Product | Pitch Documents | Basecamp |
| GitFlow | Version Control | Codebase | Branch Diagrams | Git |


#### Case Studies

- *Agile Sprints (Jira):* Demonstrates iterative planning and task management within a sprint,
  emphasising working software and team communication.

- *DevOps Pipeline (GitLab CI/CD):* Automates build, test, and deployment, enabling continuous delivery and faster feedback loops.

- *Design Thinking (Miro):* Facilitates user-centric design through collaborative visualization of user journeys and needs.


### Emerging Trends and Influences

Modern methodologies strive for a balance between structured processes and pragmatic adaptation
to project needs, learning from the pitfalls of overly rigid approaches like RUP.

Ethical considerations, such as GDPR compliance, are increasingly being embedded into development
processes to ensure responsible software creation.

AI tools like GitHub Copilot are challenging traditional practices like pair programming, prompting
a re-evaluation of established norms.

Green software methodologies are emerging to track and reduce the environmental impact of software,
including measuring CO2 emissions per API call.


### Conclusion

Computing methodologies continue to evolve, adapting to new challenges and technologies. While specific
tools and techniques may change, the fundamental need for structured approaches to manage the complexity
of software development remains constant. The principles behind today's methodologies often echo practices
from earlier eras, highlighting the cyclical nature of innovation in this field. The key lies not in
blindly adopting the latest trend, but in understanding the underlying principles and adapting them
pragmatically to the specific context of each project.
