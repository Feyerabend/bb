
## Understand Programming

In the late 1980s and early 1990s, I felt completely disillusioned about the possibility of being
understood or accepted by anyone in the academic or institutional world. I tried to connect with
various departments and institutions at the university, but nothing came of it. My ideas seemed
asynchronous with the prevailing trends of the time.

I couldn't find any space that explored programming in the way I understood it, so I started writing
my own papers and collecting my thoughts--just for myself. I'd finish them, then throw them into a
"drawer" (or to be correct: a folder). At one point, I tried to publish some of my ideas, but they
were heavily misunderstood and distorted when they went to print. It was such a discouraging experience
that I gave up on the idea of publishing altogether.

Still, I didn't stop developing my ideas. I kept working on them, refining them, and finding ways
to express what I was exploring. One of the results of that work is a document from the early 1990s.
It's printed on one of the laser printers that were just becoming available back then, probably at
300 dpi. It represents where I was at that time, both in terms of technology and my own thinking.


### Reflections

"Understand Programming" presents an interdisciplinary framework for viewing programming through
linguistic, psychological, and cognitive lenses. It emphasizes programming not just as a technical
exercise but as a human-centered activity deeply intertwined with how we process, understand, and
construct meaning. Modern developments in cognitive science, programming language theory, neurolinguistics,
and cognitive load theory could enrich this perspective, offering practical insights for improving
programming education, language design, and software development.

Written in the early 1990s, the text emerged in an era when personal computing was becoming mainstream,
yet programming methodologies prioritized technical precision over human engagement. Philosophical
constructs like constructivism and intuitionism, influential in mathematics and epistemology, were
rarely applied to programming. This work sought to bridge that gap, framing programming as an
interpretative act grounded in language, logic, and meaning-making.

The rise of graphical user interfaces during this period made computers more accessible but
further disconnected users from the programming processes underlying these systems. This divide
underscored the need to understand programming as a fundamentally human-centered activity. The text
proposed that programming involves not only interfacing with machines but also understanding ourselves
through language and cognitive constructs. I was very much inspired by Lisp Machines, Xerox Star
and the Apple Macintosh.

Inspiration also came from the Second International Conference on Logic Programming, held in 1984 in
Uppsala, where my university was based. The event introduced me to foundational concepts of logic
programming, particularly Prolog and LISP. We had a Lisp Machine at the university, a pinnacle of
advanced computing at the time. However, I never interacted with the machine until half a year ago,
when encountering one felt like rediscovering a lost artifact from a pivotal time in my academic
journey.

Although drawn to programming, I approached it philosophically, focusing on logic and its connection
to computation. This lens enabled me to explore programming languages' foundational principles and
their implications for human cognition. By examining programming through the intersection of philosophy,
linguistics, and psychology, I aimed to critique and expand the prevailing reductionist views of
the time.

"Understand Programming" was both a critique of the existing state of computing and a call to rethink
programming as a creative, interpretive, and deeply human process. It sought to challenge the technical
dogmas of the field, advocating for a more holistic approach that embraced the linguistic and cognitive
complexity of programming. The work remains an attempt to reimagine programming as a meaningful act
of human engagement, creativity, and discovery.


### Programming languages, linguistics, and human cognition

Drawing from the Greek *hermeneuein*--to explain, say, or translate--the text likens understanding programming
languages to interpreting a text. This parallels Noam Chomsky's distinction between *competence* (internal
knowledge of syntax and semantics) and *performance* (practical application), a framework that aligns with
programming's dual nature: grasping a language's structure and using it to create functional software.

Modern *computational linguistics* and *machine learning* advances, such as GPT-4 and neural machine translation,
demonstrate how programming languages are "interpreted" by machines. These technologies link linguistic theory
to programming, bridging human and machine cognition through AI-assisted coding tools (like GitHub Copilot).

Programming is also a *cognitive negotiation*, engaging mental models of problems, language syntax, and iterative 
feedback. Research into programming psychology and cognitive load theory shows how different paradigms (e.g.
object-oriented vs. functional programming) affect problem-solving efficiency, underscoring the interplay
between cognitive processes and programming.


### Constructivism and program development

The *constructivist philosophy*, which views knowledge as emerging through active engagement, resonates with
programming as a dynamic, iterative process of discovery and refinement. This idea prefigured modern practices
like *Test-Driven Development* (TDD), *Agile*, and *Extreme Programming* (XP), which emphasize incremental learning
and continuous improvement.

In education and development, iterative methods foster understanding by breaking problems into manageable chunks,
reflecting a constructivist mindset. Similarly, tools like TDD and pair programming align with this philosophy,
enabling programmers to "construct" solutions while continuously testing and revising their work.


### Cognitive science, HCI, and programming interfaces

Chomsky's competence versus performance framework has implications for *cognitive science*, particularly in
understanding how the brain processes programming. Writing and debugging code require significant cognitive
effort, involving brain regions associated with language, problem-solving, and mathematical reasoning. This
mirrors how natural language is processed, suggesting that programming is both a linguistic and cognitive activity.

The interface between programmers and machines, anticipated in the text, prefigures modern advances in human-computer
interaction (HCI). Integrated Development Environments (IDEs), real-time collaboration tools, and visual debugging
interfaces aim to reduce *cognitive load* and make programming more intuitive. By enhancing feedback and collaboration,
these tools embody the principles of cognitive efficiency.


### Programming languages as reflections of thought

Programming languages are more than technical tools; they reflect cognitive processes and societal conventions. The
evolution of language theory, from rule-based systems to domain-specific languages (DSLs), visual programming, and
multi-paradigm languages, illustrates an effort to align languages with *human cognitive models*. Functional and logic
programming, for example, continue to shape how programmers think about problems.

The text's distinction between *a-understanding* (syntax and semantics) and *b-understanding* (creative application)
remains relevant. It anticipates modern studies on expertise, where experienced programmers internalize patterns
and rapidly navigate complex systems. This framework aligns with cognitive science's ongoing exploration of
theoretical knowledge versus practical skill.


### Conclusion

These ideas were explored in the late 1980s and early 1990s. Some themes, such as the intersection of programming
with *language theory*, *cognition*, and the *iterative process* of software development, are now more central to
modern discussions in software engineering and cognitive science.

In some ways, I anticipated some trends that became mainstream only decades later. The rise of AI-assisted programming,
the growth of cognitive science applications in programming education, and the increasing importance of user-friendly
interfaces and tools all echo ideas from thought I had at the time.

It's a timeless nature of some of these core concepts--how programming, cognition, and language will always be deeply
intertwined--and how ideas that may have seemed unconventional or early on can eventually shape how we understand
and interact with technology.
