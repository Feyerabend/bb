
## Understand Programming

In the late 1980s and early 1990s, I felt completely disillusioned about the possibility of being
understood or accepted by anyone in the academic or institutional world. I tried to connect with
various departments and institutions at the university, but nothing came of it. My ideas seemed
asynchronous with the prevailing trends of the time.

I couldn’t find any space that explored programming in the way I understood it, so I started writing
my own papers and collecting my thoughts—just for myself. I’d finish them, then throw them into a
drawer. At one point, I tried to publish some of my ideas, but they were heavily misunderstood and
distorted when they went to print. It was such a discouraging experience that I gave up on the idea
of publishing altogether.

Still, I didn’t stop developing my ideas. I kept working on them, refining them, and finding ways
to express what I was exploring. One of the results of that work is a document from the early 1990s.
It’s printed on one of the laser printers that were just becoming available back then, probably at
300 dpi. It represents where I was at that time, both in terms of technology and my own thinking.

"Understand Programming" presents a interdisciplinary framework for considering programming from a
linguistic, psychological, and cognitive perspective. Modern research in cognitive science, programming
language theory, neurolinguistics, and cognitive load could expand and deepen this view (in general),
providing a richer understanding of how the brain processes, understands, and constructs programs.
This area of study also has practical implications for improving programming education, language design,
and software development processes.

The text, "Understand Programming", tries to present an in-depth exploration of how programming languages
and the act of programming can be understood through linguistic, psychological, and conceptual lenses.
Here, I propose a shift from traditional technical analyses of programming toward a more holistic,
linguistically-informed perspective. The text thus bridges multiple domains, including linguistics,
cognitive science, and the philosophy of language, to rethink how we engage with programming languages
and, by extension, with the brain's interaction with these languages.


### The linguistic view of programming languages

The text draws on the Greek verb hermeneuein, which means "to explain, say, or translate," to underscore
how understanding a programming language can be akin to translating or interpreting a text. This parallels
Noam Chomsky's theory of linguistic competence versus performance (which influence me at the time).
In programming, this distinction might mirror a programmer's inherent understanding of a language's
syntax and semantics versus their ability to implement it (the performance of creating working software).

Recent research in computational linguistics has explored how language models (e.g. GPT-3, GPT-4) generate
human-like language outputs by learning grammar and syntax. These models could inform our understanding
of how programming languages are "interpreted" by computers, providing a connection between cognitive
models of language and the functioning of programming languages.


### Cognitive science and the brain

The comparison to Chomsky's concept of competence versus performance has direct links to cognitive science,
especially when considering how the brain processes both natural languages and programming languages.
While Chomsky's theories mostly focus on natural language, the cognitive load required for a programmer
to read and understand code, then produce it, could be modeled using cognitive theories of language processing.

Recent research into neuroscience and the cognitive load of programming has found that writing code involves
significant mental effort, often invoking the same brain regions as those used in problem-solving and complex
mathematical reasoning. Understanding the brain's interaction with both natural and programming languages
could reveal ways in which programmers might be able to optimise their learning or debugging processes.


### Understanding programming as constructivism

I was deeply interested in “intuitionism” and “constructivism” in philosophy, particularly their relevance
to programming and mathematics. I emphasized the significance of “constructivism” in programming and the role
of “constructive proofs” in mathematics. This philosophical perspective, rooted in constructivist epistemology,
asserts that knowledge emerges through active engagement with the world. In this view, programming becomes a
dynamic process of discovery and understanding, evolving as the programmer interacts with the machine-—much like
language develops and transforms through use and context.

This idea ties into recent research in learning theory and problem-solving models in education. Particularly,
test-driven development (TDD) emphasizes this process of iterative learning, where programmers "construct" solutions
in small, manageable chunks while continuously testing their assumptions.


### The relationship between programming and human cognition

I suggest that programming should be seen not only as a technical task but as an act of cognitive negotiation.
This mirrors recent studies in programming psychology and human-computer interaction (HCI), which have found
that programming involves a complex interplay between mental models (i.e. a programmer's internal representation
of the problem and solution), the syntax of programming languages, and the feedback loop from the computer.

Studies in cognitive load theory have investigated how different programming paradigms (e.g. object-oriented
programming vs. functional programming) affect mental processing and problem-solving efficiency, providing
further insight into the assertion that the "construction" of code is deeply entwined with the way our brains work.


### Recent developments in programming language research

The reflections on rule-based systems (very much a thought of the 80s, logic programming and expert systems),
language syntax, and control structures align with the work done in the field of domain-specific languages (DSLs),
where specific language constructs are designed to better express particular problem domains. Furthermore,
language theory has evolved with innovations like visual programming languages and programming-by-example
interfaces, which attempt to make programming more accessible by aligning programming languages more closely
with natural human cognition. However, I today do not consider them to really aim at the same target as
traditional programming languages.

Additionally, the development of program synthesis and AI-assisted programming (think GitHub Copilot) is a direct
example of how recent technology has bridged the gap between human linguistic capabilities and programming
languages. These tools, based on machine learning, can aid in constructing programs by predicting code completions
or suggesting entire functions, transforming how we interact with the programming process.


### Linguistic theories and programming languages

In the early '90s, computational linguistics was still developing, but the idea of understanding programming
languages as a form of translation or interpretation ('hermeneuein') was apparently asynchronous with its time.
But this connects with modern work on program synthesis and machine learning-based code generation, where natural
language processing (NLP) techniques are applied to generate or understand code.

The idea that programming languages could be seen through a linguistic lens echoes contemporary work in neural
machine translation systems, which have increasingly bridged the gap between natural language understanding and
code generation (GitHub Copilot or ChatGPT, which is now able to generate code from natural language descriptions).


### Cognitive models of programming

I discuss mental models programmers use to understand and write code, which aligns with the development of
cognitive load theory and its application in programming. The study of cognitive load—how information processing
affects the brain's ability to complete tasks—has become a key part of understanding how programmers work and
learn, which was not as widely explored in the early '90s.

Modern studies on programming psychology and neuroscience of programming are now regularly exploring the very
ideas outlined about how programmers interact with programming languages and how cognitive resources are allocated
during software development. Research into the cognitive effort involved in debugging or reading code often
supports the idea that programming is both a linguistic and cognitive process, something hinted at.


### Constructivism and program development

The concept of constructivism in programming (the idea of learning and building understanding through iterative
steps and revisions) was present in this text long before it became a mainstream concept in modern development
practices. In the early '90s, Test-Driven Development (TDD) and other iterative methods like Extreme Programming
(XP) were just starting to gain traction in the development community.

Now, TDD is a standard approach, especially in Agile and DevOps methodologies, and pair programming and continuous
integration rely heavily on a constructivist mindset. The emphasis on continuous, evolving understanding of both
internal and external problems through iteration is something that resonates with modern Agile development and
lean software development philosophies.


### Programming and Human-Computer Interaction (HCI)

The reflections on the interface between the programmer and the machine might have prefigured the human-computer
interaction field's growth. The development of programming tools, IDEs (Integrated Development Environments),
and visual programming languages in the late 1990s and beyond have increasingly focused on reducing cognitive
load and making programming more intuitive.

The role of documentation and program revision also parallel discussions in HCI and software engineering regarding
the need for clear, accessible documentation and tools that aid in the collaborative development process. Modern
IDEs often include features like real-time collaboration, code suggestions, and visual debugging tools to make
this process more fluid.


### Evolution of programming language theory

The hypothesis that programming languages are not just technical tools but also reflect cognitive processes and
societal conventions aligns well with modern research in programming language design. For instance, the rise of
domain-specific languages (DSLs) and multi-paradigm languages today reflect a desire to create languages that
better fit the cognitive models of users (programmers). The work on language constructs in functional programming
(e.g. Haskell) or logic programming (e.g. Prolog) is also influenced by these insights into how language shapes
thinking.


### The concept of ‘Understanding’ in programming:

The concept of a-understanding (understanding the syntax and meaning of a program) and b-understanding (the
ability to create new solutions based on understanding) was prescient in understanding the mental processes
behind programming. This anticipates the mental models researchers often discuss today: how experienced programmers
internalise programming patterns, recognise design patterns, and rapidly navigate complex systems.

Furthermore, the distinction between competence and performance in programming aligns with later developments
in expert systems, machine learning, and the study of expertise in cognitive science, where the distinction
between theoretical knowledge and its practical application continues to be explored.


### Conclusion

These ideas were explored in the late 1980s and early 1990s. Some themes, such as the intersection of programming
with language theory, cognition, and the iterative process of software development, are now more central to
modern discussions in software engineering and cognitive science.

In some ways, I anticipated some trends that became mainstream only decades later. The rise of AI-assisted programming,
the growth of cognitive science applications in programming education, and the increasing importance of user-friendly
interfaces and tools all echo ideas from thought I had at the time.

It’s a timeless nature of some of these core concepts—-how programming, cognition, and language will always be deeply
intertwined-—and how ideas that may have seemed unconventional or early on can eventually shape how we understand
and interact with technology.
