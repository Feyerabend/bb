<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Gray Code Rotary Encoder</title>
<style>
  body { 
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    text-align: center;
    margin: 0;
    padding: 20px;
    background-color: #f8f9fa;
  }
  
  .container {
    max-width: 500px;
    margin: 0 auto;
    background: white;
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    padding: 30px;
  }
  
  h2 {
    color: #2c3e50;
    margin-bottom: 10px;
  }
  
  .description {
    color: #666;
    margin-bottom: 25px;
    line-height: 1.5;
  }
  
  canvas { 
    border: 2px solid #ddd;
    border-radius: 50%;
    cursor: pointer;
    margin: 20px 0;
    transition: box-shadow 0.2s ease;
  }
  
  canvas:hover {
    box-shadow: 0 4px 15px rgba(0,0,0,0.2);
  }
  
  .output {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 15px;
    margin-top: 20px;
  }
  
  .output-item {
    background: #f8f9fa;
    padding: 15px;
    border-radius: 6px;
    border: 1px solid #e9ecef;
  }
  
  .output-label {
    font-weight: 600;
    color: #495057;
    font-size: 14px;
    margin-bottom: 5px;
  }
  
  .output-value {
    font-family: 'Courier New', monospace;
    font-size: 18px;
    font-weight: bold;
    color: #2c3e50;
  }
  
  .position-info {
    margin-top: 15px;
    padding: 10px;
    background: #e7f3ff;
    border-radius: 6px;
    color: #0066cc;
    font-size: 14px;
  }
  
  .bit-explanation {
    margin-top: 20px;
    text-align: left;
    background: #fff8e1;
    padding: 15px;
    border-radius: 6px;
    border-left: 4px solid #ffc107;
  }
  
  .bit-explanation h4 {
    margin-top: 0;
    color: #f57f17;
  }
  
  .error-analysis {
    margin-top: 20px;
    text-align: left;
    background: #f3e5f5;
    padding: 20px;
    border-radius: 6px;
    border-left: 4px solid #9c27b0;
  }
  
  .error-analysis h4 {
    margin-top: 0;
    color: #7b1fa2;
  }
  
  .comparison {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 20px;
    margin: 15px 0;
  }
  
  .binary-errors, .gray-advantages {
    background: white;
    padding: 15px;
    border-radius: 6px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
  }
  
  .binary-errors h5 {
    color: #d32f2f;
    margin-top: 0;
    margin-bottom: 10px;
  }
  
  .gray-advantages h5 {
    color: #388e3c;
    margin-top: 0;
    margin-bottom: 10px;
  }
  
  .comparison ul {
    margin: 0;
    padding-left: 18px;
    font-size: 14px;
    line-height: 1.5;
  }
  
  .comparison li {
    margin-bottom: 8px;
  }
  
  .demo-button {
    background: #9c27b0;
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 14px;
    margin: 15px 0 10px 0;
    transition: background-color 0.2s ease;
  }
  
  .demo-button:hover {
    background: #7b1fa2;
  }
  
  .error-output {
    background: white;
    padding: 15px;
    border-radius: 6px;
    border: 1px solid #e0e0e0;
    font-family: 'Courier New', monospace;
    font-size: 13px;
    line-height: 1.4;
    min-height: 40px;
    display: none;
  }
  
  .error-output.show {
    display: block;
  }
  
  .transition-error {
    color: #d32f2f;
    font-weight: bold;
  }
  
  .transition-safe {
    color: #388e3c;
    font-weight: bold;
  }
  
    @media (max-width: 480px) {
    .container {
      margin: 10px;
      padding: 20px;
    }
    
    canvas {
      width: 250px;
      height: 250px;
    }
    
    .output {
      grid-template-columns: 1fr;
    }
    
    .comparison {
      grid-template-columns: 1fr;
    }
  }
</style>
</head>
<body>
  <div class="container">
    <h2>Gray Code Rotary Encoder Disk (3-bit)</h2>
    <p class="description">
      Click the disk to rotate it step by step. The outer ring represents bit 0, 
      middle ring is bit 1, and inner ring is bit 2. Gray code ensures only one bit changes between adjacent positions.
    </p>
    
    <canvas id="encoder" width="300" height="300"></canvas>
    
    <div class="output">
      <div class="output-item">
        <div class="output-label">Gray Code</div>
        <div class="output-value" id="gray">000</div>
      </div>
      <div class="output-item">
        <div class="output-label">Binary Equivalent</div>
        <div class="output-value" id="binary">000</div>
      </div>
    </div>
    
    <div class="position-info">
      Position: <span id="position">0</span> of 7
    </div>
    
    <div class="bit-explanation">
      <h4>How it works:</h4>
      <p>Each ring represents a bit position. Dark segments = 1, Light segments = 0. 
      The red pointer shows the current reading position. Gray code prevents 
      ambiguous readings that can occur with binary encoding when multiple bits 
      change simultaneously.</p>
    </div>
    
    <div class="error-analysis">
      <h4>Error Reduction Benefits:</h4>
      <div class="comparison">
        <div class="binary-errors">
          <h5>Binary Encoding Issues:</h5>
          <ul>
            <li><strong>Multi-bit transitions:</strong> Going from 3 (011) to 4 (100) changes all 3 bits</li>
            <li><strong>Timing errors:</strong> If bits don't switch simultaneously, temporary invalid readings occur</li>
            <li><strong>Mechanical tolerance:</strong> Slight misalignment can cause multiple false readings</li>
            <li><strong>Error probability:</strong> Up to 7 incorrect values possible during transition</li>
          </ul>
        </div>
        <div class="gray-advantages">
          <h5>Gray Code Advantages:</h5>
          <ul>
            <li><strong>Single-bit changes:</strong> Only one bit changes between adjacent positions</li>
            <li><strong>No ambiguous states:</strong> Even during transition, reading is either old or new value</li>
            <li><strong>Fault tolerance:</strong> Mechanical imperfections cause at most Â±1 position error</li>
            <li><strong>Error probability:</strong> Maximum 1 incorrect adjacent value during transition</li>
          </ul>
        </div>
      </div>
      
      <div class="error-demo">
        <button id="errorDemo" class="demo-button">Simulate Transition Errors</button>
        <div id="errorOutput" class="error-output"></div>
      </div>
    </div>
  </div>

<script>
const canvas = document.getElementById('encoder');
const ctx = canvas.getContext('2d');
const center = 150;
let position = 0; // 0-7

const grayCodes = [
  '000', '001', '011', '010', '110', '111', '101', '100'
];

const binaryCodes = [
  '000', '001', '010', '011', '100', '101', '110', '111'
];

function drawDisk(pos) {
  ctx.clearRect(0, 0, 300, 300);
  
  const total = 8;
  const angleStep = (2 * Math.PI) / total;
  const startAngle = -Math.PI / 2; // Start at top
  
  // Draw 3 concentric rings for 3 bits (outer to inner)
  const ringRadii = [125, 100, 75]; // Outer, middle, inner
  const ringWidths = [25, 25, 25];
  
  for (let bit = 0; bit < 3; bit++) {
    for (let i = 0; i < total; i++) {
      const gray = grayCodes[i];
      const bitValue = gray[bit] === '1';
      
      ctx.beginPath();
      ctx.arc(
        center, center,
        ringRadii[bit],
        startAngle + i * angleStep,
        startAngle + (i + 1) * angleStep
      );
      ctx.arc(
        center, center,
        ringRadii[bit] - ringWidths[bit],
        startAngle + (i + 1) * angleStep,
        startAngle + i * angleStep,
        true
      );
      ctx.closePath();
      
      // Use distinct colors for better visibility
      if (bitValue) {
        ctx.fillStyle = bit === 0 ? '#2c3e50' : bit === 1 ? '#34495e' : '#4a5568';
      } else {
        ctx.fillStyle = bit === 0 ? '#ecf0f1' : bit === 1 ? '#d5dbdb' : '#cbd5e0';
      }
      ctx.fill();
      
      // Add subtle border
      ctx.strokeStyle = '#95a5a6';
      ctx.lineWidth = 0.5;
      ctx.stroke();
    }
  }
  
  // Draw center circle
  ctx.beginPath();
  ctx.arc(center, center, 45, 0, 2 * Math.PI);
  ctx.fillStyle = '#ecf0f1';
  ctx.fill();
  ctx.strokeStyle = '#95a5a6';
  ctx.lineWidth = 2;
  ctx.stroke();
  
  // Draw pointer (more precise)
  const pointerAngle = startAngle + (pos + 0.5) * angleStep;
  const pointerLength = 130;
  
  ctx.beginPath();
  ctx.moveTo(center, center);
  ctx.lineTo(
    center + Math.cos(pointerAngle) * pointerLength,
    center + Math.sin(pointerAngle) * pointerLength
  );
  ctx.strokeStyle = '#e74c3c';
  ctx.lineWidth = 3;
  ctx.stroke();
  
  // Add pointer tip
  ctx.beginPath();
  ctx.arc(
    center + Math.cos(pointerAngle) * pointerLength,
    center + Math.sin(pointerAngle) * pointerLength,
    4, 0, 2 * Math.PI
  );
  ctx.fillStyle = '#c0392b';
  ctx.fill();
  
  // Add bit labels
  ctx.fillStyle = '#2c3e50';
  ctx.font = '12px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('Bit 0', center + 140, center + 5);
  ctx.fillText('Bit 1', center + 115, center + 5);
  ctx.fillText('Bit 2', center + 90, center + 5);
}

function grayToBinary(grayCode) {
  let binary = grayCode[0];
  for (let i = 1; i < grayCode.length; i++) {
    const grayBit = parseInt(grayCode[i]);
    const prevBinaryBit = parseInt(binary[i - 1]);
    binary += (grayBit ^ prevBinaryBit).toString();
  }
  return binary;
}

function updateDisplay() {
  const gray = grayCodes[position];
  const binary = grayToBinary(gray);
  
  document.getElementById('gray').textContent = gray;
  document.getElementById('binary').textContent = binary;
  document.getElementById('position').textContent = position;
  
  drawDisk(position);
}

// Event listeners
canvas.addEventListener('click', (e) => {
  // Add click animation
  canvas.style.transform = 'scale(0.98)';
  setTimeout(() => {
    canvas.style.transform = 'scale(1)';
  }, 100);
  
  position = (position + 1) % 8;
  updateDisplay();
});

// Keyboard support
document.addEventListener('keydown', (e) => {
  if (e.key === 'ArrowRight' || e.key === ' ') {
    e.preventDefault();
    position = (position + 1) % 8;
    updateDisplay();
  } else if (e.key === 'ArrowLeft') {
    e.preventDefault();
    position = (position - 1 + 8) % 8;
    updateDisplay();
  }
});

// Add smooth transitions
canvas.style.transition = 'transform 0.1s ease';

// Error demonstration functionality
document.getElementById('errorDemo').addEventListener('click', () => {
  const output = document.getElementById('errorOutput');
  output.classList.add('show');
  
  // Simulate transition from position 3 to 4 (worst case for binary)
  const binaryTransition = {
    from: 3, to: 4,
    fromBinary: binaryCodes[3], // 011
    toBinary: binaryCodes[4],   // 100
    fromGray: grayCodes[3],     // 010
    toGray: grayCodes[4]        // 110
  };
  
  let demo = '<strong>Transition Example: Position 3 â 4</strong><br><br>';
  
  demo += '<span class="transition-error">Binary Encoding Issues:</span><br>';
  demo += `From: ${binaryTransition.fromBinary} (position ${binaryTransition.from})<br>`;
  demo += `To:   ${binaryTransition.toBinary} (position ${binaryTransition.to})<br>`;
  demo += 'All 3 bits must change simultaneously!<br>';
  demo += 'Possible intermediate readings during transition:<br>';
  demo += 'â¢ 001 (position 1) - ERROR: -2 positions<br>';
  demo += 'â¢ 010 (position 2) - ERROR: -1 position<br>';
  demo += 'â¢ 101 (position 5) - ERROR: +1 position<br>';
  demo += 'â¢ 110 (position 6) - ERROR: +2 positions<br>';
  demo += 'â¢ 111 (position 7) - ERROR: +3 positions<br><br>';
  
  demo += '<span class="transition-safe">Gray Code Benefits:</span><br>';
  demo += `From: ${binaryTransition.fromGray} (position ${binaryTransition.from})<br>`;
  demo += `To:   ${binaryTransition.toGray} (position ${binaryTransition.to})<br>`;
  demo += 'Only bit 2 changes (0â1)<br>';
  demo += 'During transition, reading is either:<br>';
  demo += `â¢ ${binaryTransition.fromGray} (position ${binaryTransition.from}) - Previous position<br>`;
  demo += `â¢ ${binaryTransition.toGray} (position ${binaryTransition.to}) - New position<br>`;
  demo += 'Maximum error: Â±1 position<br><br>';
  
  demo += '<strong>Error Reduction:</strong><br>';
  demo += 'Binary: Up to 7 possible incorrect readings<br>';
  demo += 'Gray Code: Maximum 1 adjacent reading<br>';
  demo += 'Improvement: ~85% reduction in maximum error';
  
  output.innerHTML = demo;
});

function countBitDifferences(code1, code2) {
  let differences = 0;
  for (let i = 0; i < code1.length; i++) {
    if (code1[i] !== code2[i]) differences++;
  }
  return differences;
}

// Initialize
updateDisplay();
</script>
</body>
</html>