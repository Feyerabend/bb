
## WAM

The WAM (Warren Abstract Machine) is a virtual machine specifically designed to
execute programs written in Prolog. It's typically seen as part of a compiler
back-end or runtime system rather than a full compiler on its own. To understand
its role and how it fits into the broader context of compilers and virtual machines,
let’s break it down.


### 1. WAM as a Virtual Machine

The WAM is an abstract machine, which means it's a virtual machine that provides
an execution model for Prolog programs. It was created to make the execution of
Prolog more efficient by abstracting away the underlying hardware and operating 
system specifics. The WAM is not meant to be a standalone language or system for
writing programs; instead, it serves as an intermediate layer between the source
code (written in Prolog) and the hardware (machine code). It interprets or executes 
the bytecode (or intermediate representation) generated by a Prolog compiler.
In the context of a virtual machine (VM), the WAM serves the role of providing
an execution environment for Prolog programs. Instead of interpreting the Prolog
source directly or compiling it to native machine code, Prolog code is compiled
into a lower-level intermediate code that is then executed by the WAM.


### 2. WAM as a Compiler Back-End

In a Prolog compiler, the role of WAM is as an intermediate compilation target.
A Prolog source code file is first parsed and compiled by a Prolog front-end.
The front-end might generate an intermediate representation, often involving the
construction of a WAM code. The WAM code is then executed by the WAM interpreter,
which simulates the execution of the Prolog program on a hardware-independent
virtual machine.

This makes the WAM a key component in optimising and managing the execution of
Prolog code across different platforms without needing to write a custom backend
for each one.


### 3. Role in Relation to Compilers and VMs

The WAM is part of the back-end of a Prolog compiler. After the Prolog code is
compiled into an intermediate form, this intermediate code is executed by the WAM.
The WAM code is not machine code but a low-level intermediate form that is easier
to execute than high-level Prolog source code. This allows for cross-platform
portability (since the WAM can be implemented on different architectures), 
efficient execution, and optimisation.

Thus, the WAM is a bridge between high-level language (Prolog) and machine-level
execution. It helps with the portability of Prolog implementations across different
platforms.

The WAM is a specialised virtual machine designed specifically for Prolog. It
operates at a higher level of abstraction than machine code but is much more
efficient than interpreting Prolog directly.

It can be considered an abstract machine because it defines a model of computation
for Prolog programs, with its own instructions, stack management, and execution strategy.
Like other VMs (e.g. Java Virtual Machine or Python’s CPython interpreter), the WAM
abstracts away the details of the underlying hardware, which makes it easier to
implement Prolog on different systems without needing to rewrite the compiler
for each architecture.


### 4. WAM's Role in the Compilation Pipeline

To sum it up, the WAM's role in the context of compilers and virtual machines
can be viewed as follows:

- Compiler: It is the target for Prolog compilers. Once the Prolog code is parsed
and analysed, the compiler generates WAM code as an intermediate representation,
which is then executed by the WAM virtual machine. The compiler translates the
Prolog source into this more efficient intermediate code.

- Virtual Machine: The WAM acts as an execution environment that interprets and
executes the generated intermediate code. It provides an abstract execution model
for Prolog programs, meaning you don't need to compile directly to machine code
but can run the WAM code on any system with a WAM interpreter.


### 5. Comparison to Other VMs

The WAM is quite similar to other virtual machines in that it:
Provides an abstraction layer between source code and hardware.
Is designed to make execution more efficient.

Offers portability across different platforms (as long as the WAM
interpreter is implemented for those platforms).
However, unlike more general-purpose VMs (such as the Java Virtual
Machine or the Python VM), the WAM is specialised for executing
Prolog code, so its design is tailored to the specific needs and
characteristics of Prolog's logical execution model, such as
backtracking and unification.

#### Conclusion

- *WAM as a VM:* It serves as a virtual machine that interprets or executes
Prolog programs, abstracting away hardware details and providing a
platform-independent execution environment.

- *WAM as a compiler back-end:* It is a key component of the Prolog compiler
pipeline, converting the high-level Prolog code into an intermediate form
(WAM code) that can be executed efficiently on the WAM virtual machine.

- *WAM in relation to VMs:* It functions similarly to other virtual machines in
terms of providing an abstraction layer, but its focus is specifically on 
Prolog’s execution model and logical operations.
