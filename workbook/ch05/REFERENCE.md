
## References

- Aho, A.V. (2007). *Compilers: principles, techniques, & tools*. (2nd ed.) Boston: Pearson Addison-Wesley.  
  - Often referred to as the "Dragon Book," this is one of the definitive texts on compiler design. It
    covers the theoretical underpinnings of compilers, from lexical analysis to code generation, and
    provides detailed algorithms and techniques used to build a compiler. This book is a comprehensive
    resource for both students and professionals looking to deepen their understanding of compiler
    construction.

- Cooper, K.D., & Torczon, L. (2004). *Engineering a compiler*. San Francisco, Calif.: Morgan Kaufmann.  
  - A more practical and hands-on approach to compiler construction, this book emphasizes engineering and
    real-world implementation of compilers. Cooper and Torczon focus on optimization and the trade-offs
    involved in making efficient compilers. It's a great companion to Aho's book, providing a more applied
    perspective with detailed examples and case studies of building compilers for modern programming languages.

- Fowler, M. (2010). *Domain-Specific Languages*. Addison-Wesley.  
  - Fowler's book on Domain-Specific Languages (DSLs) explores the concept of designing languages tailored
    to specific problem domains. It provides a detailed overview of DSLs, from internal DSLs embedded in
    programming languages to external DSLs that stand on their own. The book covers the principles of designing,
    implementing, and using DSLs, with numerous examples from real-world applications. Fowler explains the
    advantages of using DSLs for improving developer productivity and software quality, making this an important
    resource for software architects and developers working on specialized systems.

- Jones, R. & Lins, R. (2003). *Garbage Collection: Algorithms for Automatic Dynamic Memory Management*. Wiley.  
  - This book is a comprehensive guide to garbage collection techniques, offering a deep dive into the algorithms
    that make memory management in modern programming languages more efficient. It covers a range of approaches,
    from simple reference counting to advanced mark-and-sweep and generational garbage collection strategies.
    The authors also discuss the trade-offs between different algorithms and their implications for performance
    and memory usage, making it an essential resource for developers and researchers in systems programming and
    memory management.

