
## Simple Language Compiler

A compiler pipeline for a simple programming language with I/O and string handling.


### Language Features

- *Variables*: `let x = 42;`
- *Strings*: `let name = "Alice";`
- *Arithmetic*: `+`, `-`, `*`, `/`, `%`
- *Comparisons*: `==`, `!=`, `<`, `>`, `<=`, `>=`
- *Control Flow*: `if/else`, `while`
- *I/O*: `print()`, `input()`
- *Comments*: `# This is a comment`


### Syntax Examples

```
# Variable declaration
let x = 10;
let name = "Bob";

# Printing
print("Hello, World!");
print(x + 5);

# String concatenation
print("Hello, " + name);

# Conditionals
if x > 5 {
    print("x is large");
} else {
    print("x is small");
}

# Loops
let i = 0;
while i < 10 {
    print(i);
    i = i + 1;
}

# User input
let age = 0;
print("Enter your age:");
input(age);
```


### Compiler Pipeline

1. *Lexer* (`lexer.py`) - Tokenizes source code
2. *Parser* (`parser.py`) - Builds Abstract Syntax Tree (AST)
3. *Semantic Analyzer* (`semantic.py`) - Checks for semantic errors
4. *Code Generator* (`codegen.py`) - Generates bytecode instructions
5. *Virtual Machine* (`vm.py`) - Executes bytecode


### File Structure

```
lexer.py          # Lexical analyzer (tokenizer)
ast_nodes.py      # AST node definitions
parser.py         # Syntax analyzer (parser)
semantic.py       # Semantic analyzer
codegen.py        # Code generator
vm.py             # Virtual machine executor
compiler.py       # Main compiler driver
sample1.prog      # Hello World example
sample2.prog      # Conditionals example
sample3.prog      # Loop example
sample4.prog      # Fibonacci example
Makefile          # Build automation
```


### Usage

### Using Makefile

```bash
# Run all samples
make test

# Run specific sample
make run1    # Hello World
make run2    # Conditionals
make run3    # Loops
make run4    # Fibonacci

# Run with verbose output (shows all compilation stages)
make verbose

# Show help
make help

# Clean up
make clean
```


#### Manual Execution

```bash
# Basic run
python3 compiler.py sample1.prog

# Verbose mode (shows tokenization, AST, bytecode, etc.)
python3 compiler.py sample1.prog --verbose
```


### Bytecode Instructions

The compiler generates stack-based bytecode with these instructions:

- *Stack Operations*: `PUSH`, `STORE`, `LOAD`
- *Arithmetic*: `ADD`, `SUB`, `MUL`, `DIV`, `MOD`, `NEG`
- *Comparison*: `EQ`, `NE`, `LT`, `GT`, `LE`, `GE`
- *Control Flow*: `JMP`, `JZ` (jump if zero)
- *I/O*: `PRINT`, `INPUT`
- *Control*: `HALT`


### Example Output

Running `sample1.prog`:
```
Hello, World!
The answer is: 42
50
```

Running with `--verbose` shows:
- All tokens generated by the lexer
- The complete AST structure
- Generated bytecode instructions
- Execution output
- Final memory state


### Implementation Details

- *Lexer*: Regular expression-based tokenization
- *Parser*: Recursive descent parser with operator precedence
- *Semantic Analysis*: Symbol table with scope checking
- *Code Generation*: Stack-based instruction generation with labels
- *VM*: Stack-based virtual machine with memory storage


### Extension Ideas

- Functions with parameters and return values
- Arrays and lists
- More data types (boolean, null)
- Break/continue statements
- For loops
- More operators (and, or, not)
- Standard library functions
