
## Code Generation: TAC to RISC

As we have learned TAC is an *intermediate code representation* that is often used during the
compilation process. It is a form of intermediate language that bridges the gap between
high-level source code and low-level machine code. TAC uses instructions that involve at
most three addresses or operands (hence it's name).

To recapture:

```
result = operand1 operator operand2
```

- `result` is a variable where the result of the operation will be stored.
- `operand1` and `operand2` are variables or constants involved in the operation.
- `operator` is a binary operator (such as +, -, *, etc.).

In the example code 'tac2risc.py' the TAC for the factorial program involves operations like
assignments, comparisons, and loops, which are then translated into assembly.


__1. Register Allocation__

- The get_register() is responsible for mapping variables (such as n, result) to
  physical registers in the RISC-V assembly language. The register map ensures that each
  variable in the TAC program gets a unique register (x1, x2, etc.), facilitating operations
  on them.

- The next_reg variable tracks which register is assigned next, ensuring that the program
  uses registers efficiently without overlap.


__2. Instruction Types__

The TAC instructions include different types: assignments, conditionals (if), jumps (goto),
labels, and print operations. Each type is mapped to a corresponding RISC-V-like instruction:
- *Assignment*: For example, ADDI x1, x0, 5 translates a simple assignment of 5 to a variable n
  (stored in register x1).
- *Binary Operations*: Operations such as addition, subtraction, multiplication, and division
  are represented using RISC-V's corresponding instructions like ADD, SUB, MUL, and DIV.
- *Conditional Branching*: The if statement in TAC translates into RISC-V conditional instructions
  like SLE (set less than or equal) and BEQ (branch if equal), facilitating conditional execution.
- *Unconditional Jumps*: The goto instruction translates to a J (jump) instruction in assembly.
- *Labels*: These are simply named locations in the assembly program, which provide targets for
  jump and branch instructions.
- *Print*: PRINT in TAC corresponds to outputting the value in a register in assembly.

__3. Control Flow__

The factorial program showcases a simple loop where the program repeatedly multiplies result by n,
then decrements n. This loop is managed using a goto to jump back to the loop label until the
condition for exiting the loop is met. The if statement inside the loop checks whether n <= 0,
and if true, it jumps to the end label, halting further execution of the loop. Then the goto and
label constructs allow for control flow manipulation, crucial for implementing loops and
conditionals in assembly.

__4. RISC-V-like Assembly__

The assembly language generated by the function follows a RISC-V-like syntax but is very much
simplified for the purposes of this example. It includes operations like ADDI for adding immediate
values (a constant value that is directly specified within the instruction itself, rather than
being stored in a register or memory), MUL for multiplication, and BEQ for conditional branching.
The labels (start, loop, end) provide a way to control the flow of execution.


#### Example of Translated Code:

For the given factorial program, the assembly output is:

```assembly
start:
  ADDI x1, x0, 5  # n = 5
  ADDI x2, x0, 1  # result = 1
loop:
  SLE x4, x1, x3  # if n <= 0, exit loop
  BEQ x4, x0, end  # if condition is true, jump to end
  MUL x2, x2, x1  # result = result * n
  SUB x1, x1, x5  # n = n - 1
  J loop  # jump back to loop
end:
  PRINT x2  # print result
  HALT  # stop execution
```

This output assembly code closely resembles what would be produced by an assembler from a
higher-level program, though the details of the RISC-V architecture (like exact register
usage) and optimizations might differ.

Further Concepts:
- *Intermediate Representation (IR)*: TAC serves as a kind of IR in a compiler pipeline, simplifying
  the translation from high-level language to machine code.
- *Register Management*: The allocation and tracking of registers is a key challenge in compilers
  and assemblers, as it directly affects the performance and correctness of the final executable.
- *Control Flow Analysis*: The way loops, conditionals, and jumps are represented in assembly
  highlights the importance of control flow analysis, which is crucial for generating efficient
  machine code.


### Conclusion

This translation from TAC to assembly is a simplified example of how high-level constructs
(like loops and conditionals) are broken down into lower-level instructions. It demonstrates
how a compiler or an assembler must handle variables, operations, and control flow when
converting to machine language, offering insights into both compiler design and assembly
language concepts.
