
## Temperature from BMP280

Handle I2C directly (on the Pico this is via the I2C peripheral, in both Python/MicroPython and C SDK).


### MicroPython (no external libs)

```python
from machine import Pin, I2C
import time

# BME280 default I2C address
BME280_ADDR = 0x76

# Setup I2C (GPIO 4 = SDA, GPIO 5 = SCL on Pico by convention)
i2c = I2C(0, scl=Pin(5), sda=Pin(4), freq=100000)

# Read an unsigned short (little endian)
def read_u16(addr):
    d = i2c.readfrom_mem(BME280_ADDR, addr, 2)
    return d[0] | (d[1] << 8)

# Read a signed short
def read_s16(addr):
    val = read_u16(addr)
    return val if val < 32768 else val - 65536

# Get calibration data for temperature
dig_T1 = read_u16(0x88)
dig_T2 = read_s16(0x8A)
dig_T3 = read_s16(0x8C)

# Configure sensor: oversampling x1, normal mode
i2c.writeto_mem(BME280_ADDR, 0xF4, bytes([0x27]))

def read_temperature():
    data = i2c.readfrom_mem(BME280_ADDR, 0xFA, 3)
    raw = (data[0] << 12) | (data[1] << 4) | (data[2] >> 4)

    # Compensation formula from datasheet
    var1 = (((raw >> 3) - (dig_T1 << 1)) * dig_T2) >> 11
    var2 = (((((raw >> 4) - dig_T1) * ((raw >> 4) - dig_T1)) >> 12) * dig_T3) >> 14
    t_fine = var1 + var2
    T = (t_fine * 5 + 128) >> 8
    return T / 100.0

while True:
    print("Temperature:", read_temperature(), "°C")
    time.sleep(1)
```



C (Raspberry Pi Pico SDK, no external libs)

```c
#include "pico/stdlib.h"
#include "hardware/i2c.h"
#include <stdio.h>

#define BME280_ADDR 0x76

uint16_t read_u16(uint8_t reg) {
    uint8_t buf[2];
    i2c_write_blocking(i2c0, BME280_ADDR, &reg, 1, true);
    i2c_read_blocking(i2c0, BME280_ADDR, buf, 2, false);
    return buf[0] | (buf[1] << 8);
}

int16_t read_s16(uint8_t reg) {
    int16_t val = (int16_t)read_u16(reg);
    return val;
}

int main() {
    stdio_init_all();
    i2c_init(i2c0, 100 * 1000);
    gpio_set_function(4, GPIO_FUNC_I2C); // SDA
    gpio_set_function(5, GPIO_FUNC_I2C); // SCL
    gpio_pull_up(4);
    gpio_pull_up(5);

    // Read calibration
    uint16_t dig_T1 = read_u16(0x88);
    int16_t dig_T2 = read_s16(0x8A);
    int16_t dig_T3 = read_s16(0x8C);

    // Set ctrl_meas register: oversampling x1, normal mode
    uint8_t buf[2] = {0xF4, 0x27};
    i2c_write_blocking(i2c0, BME280_ADDR, buf, 2, false);

    while (1) {
        uint8_t reg = 0xFA;
        uint8_t data[3];
        i2c_write_blocking(i2c0, BME280_ADDR, &reg, 1, true);
        i2c_read_blocking(i2c0, BME280_ADDR, data, 3, false);

        int32_t raw = (data[0] << 12) | (data[1] << 4) | (data[2] >> 4);

        int32_t var1 = ((((raw >> 3) - ((int32_t)dig_T1 << 1))) * dig_T2) >> 11;
        int32_t var2 = (((((raw >> 4) - (int32_t)dig_T1) *
                          ((raw >> 4) - (int32_t)dig_T1)) >> 12) *
                        dig_T3) >> 14;

        int32_t t_fine = var1 + var2;
        int32_t T = (t_fine * 5 + 128) >> 8;

        printf("Temperature: %.2f C\n", T / 100.0);

        sleep_ms(1000);
    }
}
```

- manually read calibration registers.
- apply Bosch’s compensation formula from the datasheet.

