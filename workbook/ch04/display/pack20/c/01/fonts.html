<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>5x8 Font Editor</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            margin: 20px;
            background: #1a1a1a;
            color: #ffffff;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        h1 {
            text-align: center;
            color: #00ff88;
            text-shadow: 0 0 10px #00ff88;
            margin-bottom: 30px;
        }
        
        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            padding: 20px;
            background: #2a2a2a;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.1);
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        label {
            font-size: 12px;
            color: #cccccc;
            text-transform: uppercase;
        }
        
        input[type="file"], button, select {
            padding: 8px 15px;
            border: 2px solid #00ff88;
            background: #333333;
            color: #ffffff;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        input[type="file"]:hover, button:hover, select:hover {
            background: #00ff88;
            color: #000000;
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.5);
        }
        
        .char-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }
        
        .char-item {
            background: #2a2a2a;
            border: 2px solid #444444;
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .char-item:hover {
            border-color: #00ff88;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
        }
        
        .char-item.selected {
            border-color: #00ff88;
            background: #003322;
            box-shadow: 0 0 25px rgba(0, 255, 136, 0.5);
        }
        
        .char-display {
            font-size: 24px;
            margin-bottom: 10px;
            color: #00ff88;
        }
        
        .char-code {
            font-size: 12px;
            color: #888888;
            margin-bottom: 10px;
        }
        
        .pixel-canvas {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 2px;
            margin: 10px auto;
            width: 60px;
            height: 96px;
        }
        
        .pixel {
            width: 10px;
            height: 10px;
            background: #444444;
            border: 1px solid #666666;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .pixel.on {
            background: #00ff88;
            box-shadow: 0 0 8px rgba(0, 255, 136, 0.6);
        }
        
        .pixel:hover {
            transform: scale(1.2);
            z-index: 10;
        }
        
        .editor {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #1a1a1a;
            border: 3px solid #00ff88;
            border-radius: 15px;
            padding: 30px;
            display: none;
            z-index: 1000;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.8);
        }
        
        .editor.active {
            display: block;
        }
        
        .editor h3 {
            margin-top: 0;
            color: #00ff88;
            text-align: center;
        }
        
        .editor-canvas {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 3px;
            margin: 20px auto;
            width: 150px;
            height: 240px;
        }
        
        .editor-pixel {
            width: 25px;
            height: 25px;
            background: #333333;
            border: 2px solid #555555;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .editor-pixel.on {
            background: #00ff88;
            border-color: #00ff88;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.8);
        }
        
        .editor-pixel:hover {
            border-color: #00ff88;
            transform: scale(1.1);
        }
        
        .editor-controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
        }
        
        .hex-output {
            background: #2a2a2a;
            border-radius: 10px;
            padding: 20px;
            margin-top: 30px;
        }
        
        .hex-output h3 {
            color: #00ff88;
            margin-top: 0;
        }
        
        .hex-code {
            background: #1a1a1a;
            border: 1px solid #444444;
            border-radius: 5px;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: #ffffff;
            overflow-x: auto;
            white-space: pre;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .copy-btn {
            margin-top: 10px;
        }
        
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            z-index: 999;
        }
        
        .overlay.active {
            display: block;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>5×8 Font Editor</h1>
        
        <div class="controls">
            <div class="control-group">
                <label>Load Font File</label>
                <input type="file" id="fileInput" accept=".c,.h,.txt" />
            </div>
            <div class="control-group">
                <label>Actions</label>
                <div style="display: flex; gap: 10px;">
                    <button onclick="resetToDefault()">Reset to Default</button>
                    <button onclick="clearAll()">Clear All</button>
                </div>
            </div>
            <div class="control-group">
                <label>Export</label>
                <div style="display: flex; gap: 10px;">
                    <button onclick="generateHexCode()">Generate C Code</button>
                    <button onclick="downloadFont()">Download Font</button>
                </div>
            </div>
        </div>
        
        <div class="char-grid" id="charGrid"></div>
        
        <div class="hex-output">
            <h3>Generated C Code</h3>
            <div class="hex-code" id="hexCode">Click "Generate C Code" to see the font array...</div>
            <button class="copy-btn" onclick="copyToClipboard()">Copy to Clipboard</button>
        </div>
    </div>
    
    <div class="overlay" id="overlay" onclick="closeEditor()"></div>
    <div class="editor" id="editor">
        <h3 id="editorTitle">Edit Character</h3>
        <div class="editor-canvas" id="editorCanvas"></div>
        <div class="editor-controls">
            <button onclick="clearCharacter()">Clear</button>
            <button onclick="invertCharacter()">Invert</button>
            <button onclick="saveCharacter()">Save</button>
            <button onclick="closeEditor()">Cancel</button>
        </div>
    </div>

    <script>
        // Default 5x8 font data with bits reversed to fix upside-down issue
        const defaultFont = [
    [0x00, 0x00, 0x00, 0x00, 0x00], // Space
    [0x00, 0x00, 0x5F, 0x00, 0x00], // !
    [0x00, 0x07, 0x00, 0x07, 0x00], // "
    [0x14, 0x7F, 0x14, 0x7F, 0x14], // #
    [0x12, 0x2A, 0x7F, 0x2A, 0x24], // $
    [0x62, 0x64, 0x08, 0x13, 0x23], // %
    [0x50, 0x22, 0x55, 0x49, 0x36], // &
    [0x00, 0x00, 0x04, 0x03, 0x00], // '
    [0x00, 0x41, 0x22, 0x1C, 0x00], // (
    [0x00, 0x1C, 0x22, 0x41, 0x00], // )
    [0x14, 0x08, 0x3E, 0x08, 0x14], // *
    [0x08, 0x08, 0x3E, 0x08, 0x08], // +
    [0x00, 0x30, 0x50, 0x00, 0x00], // ,
    [0x08, 0x08, 0x08, 0x08, 0x08], // -
    [0x00, 0x60, 0x60, 0x00, 0x00], // .
    [0x02, 0x04, 0x08, 0x10, 0x20], // /
    [0x3E, 0x51, 0x49, 0x45, 0x3E], // 0
    [0x00, 0x40, 0x7F, 0x42, 0x00], // 1
    [0x46, 0x49, 0x51, 0x61, 0x42], // 2
    [0x31, 0x4B, 0x45, 0x41, 0x21], // 3
    [0x10, 0x7F, 0x12, 0x14, 0x18], // 4
    [0x3D, 0x45, 0x45, 0x45, 0x27], // 5
    [0x30, 0x49, 0x49, 0x4A, 0x3C], // 6
    [0x07, 0x0D, 0x09, 0x71, 0x01], // 7
    [0x36, 0x49, 0x49, 0x49, 0x36], // 8
    [0x1E, 0x29, 0x49, 0x49, 0x0E], // 9
    [0x00, 0x36, 0x36, 0x00, 0x00], // :
    [0x00, 0x36, 0x76, 0x00, 0x00], // ;
    [0x00, 0x41, 0x22, 0x14, 0x08], // <
    [0x14, 0x14, 0x14, 0x14, 0x14], // =
    [0x08, 0x14, 0x22, 0x41, 0x00], // >
    [0x06, 0x09, 0x51, 0x01, 0x06], // ?
    [0x0E, 0x49, 0x4F, 0x41, 0x3E], // @
    [0x7E, 0x11, 0x11, 0x11, 0x7E], // A
    [0x36, 0x49, 0x49, 0x49, 0x7F], // B
    [0x22, 0x41, 0x41, 0x41, 0x3E], // C
    [0x1C, 0x22, 0x41, 0x41, 0x7F], // D
    [0x41, 0x49, 0x49, 0x49, 0x7F], // E
    [0x01, 0x09, 0x09, 0x09, 0x7F], // F
    [0x7A, 0x49, 0x49, 0x41, 0x3E], // G
    [0x7F, 0x08, 0x08, 0x08, 0x7F], // H
    [0x00, 0x41, 0x7F, 0x41, 0x00], // I
    [0x01, 0x3F, 0x41, 0x40, 0x20], // J
    [0x41, 0x22, 0x14, 0x08, 0x7F], // K
    [0x40, 0x40, 0x40, 0x40, 0x7F], // L
    [0x7F, 0x02, 0x0C, 0x02, 0x7F], // M
    [0x7F, 0x10, 0x0C, 0x02, 0x7F], // N
    [0x3E, 0x41, 0x41, 0x41, 0x3E], // O
    [0x06, 0x09, 0x09, 0x09, 0x7F], // P
    [0x5E, 0x21, 0x51, 0x41, 0x3E], // Q
    [0x46, 0x29, 0x19, 0x09, 0x7F], // R
    [0x31, 0x49, 0x49, 0x49, 0x46], // S
    [0x01, 0x01, 0x7F, 0x01, 0x01], // T
    [0x3F, 0x40, 0x40, 0x40, 0x3F], // U
    [0x1F, 0x20, 0x40, 0x20, 0x1F], // V
    [0x3F, 0x40, 0x38, 0x40, 0x3F], // W
    [0x63, 0x14, 0x08, 0x14, 0x63], // X
    [0x07, 0x08, 0x70, 0x08, 0x07], // Y
    [0x43, 0x45, 0x49, 0x51, 0x61], // Z
        ];

        let currentFont = JSON.parse(JSON.stringify(defaultFont));
        let editingChar = -1;
        let editingData = [];

        const charNames = [
            'Space', '!', '"', '#', '$', '%', '&', "'", '(', ')', '*', '+', ',', '-', '.', '/',
            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=', '>', '?', '@',
            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
            'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'
        ];

        function renderPixelCanvas(container, charData, isEditor = false) {
            container.innerHTML = '';
            const pixelClass = isEditor ? 'editor-pixel' : 'pixel';
            
            // Create 5x8 grid (columns x rows)
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 5; col++) {
                    const pixel = document.createElement('div');
                    pixel.className = pixelClass;
                    
                    // Check if pixel is on (bit is set)
                    const colData = charData[4 - col]; // Reverse column order as in C code
                    const isOn = (colData & (1 << row)) !== 0;
                    
                    if (isOn) {
                        pixel.classList.add('on');
                    }
                    
                    if (isEditor) {
                        pixel.addEventListener('click', () => toggleEditorPixel(col, row, pixel));
                    }
                    
                    container.appendChild(pixel);
                }
            }
        }

        function renderCharGrid() {
            const grid = document.getElementById('charGrid');
            grid.innerHTML = '';
            
            currentFont.forEach((charData, index) => {
                const charItem = document.createElement('div');
                charItem.className = 'char-item';
                charItem.onclick = () => editCharacter(index);
                
                const charDisplay = document.createElement('div');
                charDisplay.className = 'char-display';
                charDisplay.textContent = index === 0 ? '⎵' : String.fromCharCode(32 + index);
                
                const charCode = document.createElement('div');
                charCode.className = 'char-code';
                charCode.textContent = `${charNames[index]} (${32 + index})`;
                
                const canvas = document.createElement('div');
                canvas.className = 'pixel-canvas';
                
                charItem.appendChild(charDisplay);
                charItem.appendChild(charCode);
                charItem.appendChild(canvas);
                
                renderPixelCanvas(canvas, charData);
                
                grid.appendChild(charItem);
            });
        }

        function editCharacter(index) {
            editingChar = index;
            editingData = [...currentFont[index]];
            
            document.getElementById('editorTitle').textContent = `Edit Character: ${charNames[index]}`;
            document.getElementById('overlay').classList.add('active');
            document.getElementById('editor').classList.add('active');
            
            renderPixelCanvas(document.getElementById('editorCanvas'), editingData, true);
        }

        function toggleEditorPixel(col, row, pixelElement) {
            const colIndex = 4 - col; // Reverse column order
            const bitMask = 1 << row;
            
            editingData[colIndex] ^= bitMask;
            
            if (editingData[colIndex] & bitMask) {
                pixelElement.classList.add('on');
            } else {
                pixelElement.classList.remove('on');
            }
        }

        function clearCharacter() {
            editingData = [0x00, 0x00, 0x00, 0x00, 0x00];
            renderPixelCanvas(document.getElementById('editorCanvas'), editingData, true);
        }

        function invertCharacter() {
            editingData = editingData.map(byte => (~byte) & 0xFF);
            renderPixelCanvas(document.getElementById('editorCanvas'), editingData, true);
        }

        function saveCharacter() {
            if (editingChar >= 0) {
                currentFont[editingChar] = [...editingData];
                closeEditor();
                renderCharGrid();
            }
        }

        function closeEditor() {
            document.getElementById('overlay').classList.remove('active');
            document.getElementById('editor').classList.remove('active');
            editingChar = -1;
        }

        function resetToDefault() {
            currentFont = JSON.parse(JSON.stringify(defaultFont));
            renderCharGrid();
        }

        function clearAll() {
            currentFont = currentFont.map(() => [0x00, 0x00, 0x00, 0x00, 0x00]);
            renderCharGrid();
        }

        function generateHexCode() {
            let code = 'static const uint8_t font5x8[][5] = {\n';
            
            currentFont.forEach((charData, index) => {
                const hexValues = charData.map(byte => `0x${byte.toString(16).toUpperCase().padStart(2, '0')}`);
                const comment = charNames[index];
                code += `    {${hexValues.join(', ')}}, // ${comment}\n`;
            });
            
            code += '};';
            
            document.getElementById('hexCode').textContent = code;
        }

        function copyToClipboard() {
            const codeElement = document.getElementById('hexCode');
            if (codeElement.textContent === 'Click "Generate C Code" to see the font array...') {
                generateHexCode();
            }
            
            navigator.clipboard.writeText(codeElement.textContent).then(() => {
                alert('Code copied to clipboard!');
            });
        }

        function downloadFont() {
            generateHexCode();
            const code = document.getElementById('hexCode').textContent;
            const blob = new Blob([code], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'font5x8.c';
            a.click();
            URL.revokeObjectURL(url);
        }

        // Handle file input for loading font files
        document.getElementById('fileInput').addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const content = e.target.result;
                    // Parse the C file content to extract font data
                    const fontData = parseFontFile(content);
                    if (fontData && fontData.length === currentFont.length) {
                        currentFont = fontData;
                        renderCharGrid();
                        alert('Font loaded successfully!');
                    } else {
                        alert('Invalid font file format. Expected 5x8 font data.');
                    }
                } catch (err) {
                    alert('Error loading font file: ' + err.message);
                }
            };
            reader.readAsText(file);
        });

        // Parse font file content to extract font data
        function parseFontFile(content) {
            // Regular expression to match font array in C code
            const regex = /static\s+const\s+uint8_t\s+font5x8.*?\[\]\[5\]\s*=\s*{([^}]*)}/;
            const match = content.match(regex);
            if (!match) return null;

            const rows = match[1].split('\n').filter(row => row.trim().startsWith('{'));
            const fontData = rows.map(row => {
                const bytes = row.match(/0x[0-9A-Fa-f]{2}/g);
                if (!bytes || bytes.length !== 5) return null;
                return bytes.map(byte => parseInt(byte, 16));
            });

            if (fontData.some(row => !row)) return null;
            return fontData;
        }

        // Initialize the grid on page load
        renderCharGrid();
    </script>
</body>
</html>