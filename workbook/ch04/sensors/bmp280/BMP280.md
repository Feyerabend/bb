
## BME280

No External Libraries: temperature + pressure + humidity for the BME280

1. Read calibration constants (there are quite a few, from addresses 0x88–0xA1 and 0xE1–0xE7).
2. Read raw data (0xF7–0xFE).
3. Apply compensation formulas (straight from the Bosch datasheet).


### MicroPython – BME280

```python
from machine import Pin, I2C
import time

BME280_ADDR = 0x76

i2c = I2C(0, scl=Pin(5), sda=Pin(4), freq=100000)

# Helpers to read signed/unsigned
def read_u8(addr): return int.from_bytes(i2c.readfrom_mem(BME280_ADDR, addr, 1), "little")
def read_s8(addr): return read_u8(addr) - 256 if read_u8(addr) > 127 else read_u8(addr)
def read_u16(addr): return int.from_bytes(i2c.readfrom_mem(BME280_ADDR, addr, 2), "little")
def read_s16(addr):
    val = read_u16(addr)
    return val if val < 32768 else val - 65536

# Read calibration data
dig_T1 = read_u16(0x88)
dig_T2 = read_s16(0x8A)
dig_T3 = read_s16(0x8C)

dig_P1 = read_u16(0x8E)
dig_P2 = read_s16(0x90)
dig_P3 = read_s16(0x92)
dig_P4 = read_s16(0x94)
dig_P5 = read_s16(0x96)
dig_P6 = read_s16(0x98)
dig_P7 = read_s16(0x9A)
dig_P8 = read_s16(0x9C)
dig_P9 = read_s16(0x9E)

dig_H1 = read_u8(0xA1)
dig_H2 = read_s16(0xE1)
dig_H3 = read_u8(0xE3)
dig_H4 = (read_s8(0xE4) << 4) | (read_u8(0xE5) & 0x0F)
dig_H5 = (read_s8(0xE6) << 4) | (read_u8(0xE5) >> 4)
dig_H6 = read_s8(0xE7)

# Set oversampling and mode (temp, press, hum all x1, normal mode)
i2c.writeto_mem(BME280_ADDR, 0xF2, bytes([0x01]))  # Humidity oversampling x1
i2c.writeto_mem(BME280_ADDR, 0xF4, bytes([0x27]))  # Temp/press oversampling x1, normal mode

t_fine = 0

def read_data():
    global t_fine
    data = i2c.readfrom_mem(BME280_ADDR, 0xF7, 8)
    adc_p = (data[0] << 12) | (data[1] << 4) | (data[2] >> 4)
    adc_t = (data[3] << 12) | (data[4] << 4) | (data[5] >> 4)
    adc_h = (data[6] << 8) | data[7]

    # Temperature compensation
    var1 = (((adc_t >> 3) - (dig_T1 << 1)) * dig_T2) >> 11
    var2 = (((((adc_t >> 4) - dig_T1) * ((adc_t >> 4) - dig_T1)) >> 12) * dig_T3) >> 14
    t_fine = var1 + var2
    T = (t_fine * 5 + 128) >> 8

    # Pressure compensation
    var1 = t_fine - 128000
    var2 = var1 * var1 * dig_P6
    var2 = var2 + ((var1 * dig_P5) << 17)
    var2 = var2 + (dig_P4 << 35)
    var1 = ((var1 * var1 * dig_P3) >> 8) + ((var1 * dig_P2) << 12)
    var1 = (((1 << 47) + var1) * dig_P1) >> 33
    p = 1048576 - adc_p
    p = int((((p << 31) - var2) * 3125) // var1)
    var1 = (dig_P9 * (p >> 13) * (p >> 13)) >> 25
    var2 = (dig_P8 * p) >> 19
    P = ((p + var1 + var2) >> 8) + (dig_P7 << 4)

    # Humidity compensation
    v_x1 = t_fine - 76800
    v_x1 = (((((adc_h << 14) - (dig_H4 << 20) - (dig_H5 * v_x1)) + 16384) >> 15) *
            (((((((v_x1 * dig_H6) >> 10) * (((v_x1 * dig_H3) >> 11) + 32768)) >> 10) + 2097152) *
              dig_H2 + 8192) >> 14))
    v_x1 = v_x1 - (((((v_x1 >> 15) * (v_x1 >> 15)) >> 7) * dig_H1) >> 4)
    v_x1 = 0 if v_x1 < 0 else v_x1
    v_x1 = 419430400 if v_x1 > 419430400 else v_x1
    H = (v_x1 >> 12)

    return T / 100.0, P / 25600.0, H / 1024.0

while True:
    temp, press, hum = read_data()
    print("Temperature: %.2f °C  Pressure: %.2f hPa  Humidity: %.2f %%"
          % (temp, press, hum))
    time.sleep(1)
```



### C – Pico SDK BME280

```c
#include "pico/stdlib.h"
#include "hardware/i2c.h"
#include <stdio.h>

#define BME280_ADDR 0x76

// Calibration parameters
uint16_t dig_T1;
int16_t dig_T2, dig_T3;
uint16_t dig_P1;
int16_t dig_P2, dig_P3, dig_P4, dig_P5, dig_P6, dig_P7, dig_P8, dig_P9;
uint8_t dig_H1, dig_H3;
int16_t dig_H2, dig_H4, dig_H5;
int8_t dig_H6;

int32_t t_fine;

uint8_t read_u8(uint8_t reg) {
    uint8_t val;
    i2c_write_blocking(i2c0, BME280_ADDR, &reg, 1, true);
    i2c_read_blocking(i2c0, BME280_ADDR, &val, 1, false);
    return val;
}

uint16_t read_u16(uint8_t reg) {
    uint8_t buf[2];
    i2c_write_blocking(i2c0, BME280_ADDR, &reg, 1, true);
    i2c_read_blocking(i2c0, BME280_ADDR, buf, 2, false);
    return buf[0] | (buf[1] << 8);
}

int16_t read_s16(uint8_t reg) {
    return (int16_t)read_u16(reg);
}

void read_calibration() {
    dig_T1 = read_u16(0x88);
    dig_T2 = read_s16(0x8A);
    dig_T3 = read_s16(0x8C);

    dig_P1 = read_u16(0x8E);
    dig_P2 = read_s16(0x90);
    dig_P3 = read_s16(0x92);
    dig_P4 = read_s16(0x94);
    dig_P5 = read_s16(0x96);
    dig_P6 = read_s16(0x98);
    dig_P7 = read_s16(0x9A);
    dig_P8 = read_s16(0x9C);
    dig_P9 = read_s16(0x9E);

    dig_H1 = read_u8(0xA1);
    dig_H2 = read_s16(0xE1);
    dig_H3 = read_u8(0xE3);

    int8_t e4 = read_u8(0xE4);
    int8_t e5 = read_u8(0xE5);
    int8_t e6 = read_u8(0xE6);

    dig_H4 = (e4 << 4) | (e5 & 0x0F);
    dig_H5 = (e6 << 4) | (e5 >> 4);
    dig_H6 = (int8_t)read_u8(0xE7);
}

void bme280_init() {
    uint8_t buf[2];
    // Humidity oversampling x1
    buf[0] = 0xF2; buf[1] = 0x01;
    i2c_write_blocking(i2c0, BME280_ADDR, buf, 2, false);
    // Temp/press oversampling x1, normal mode
    buf[0] = 0xF4; buf[1] = 0x27;
    i2c_write_blocking(i2c0, BME280_ADDR, buf, 2, false);
}

void read_data(float *temperature, float *pressure, float *humidity) {
    uint8_t reg = 0xF7;
    uint8_t data[8];
    i2c_write_blocking(i2c0, BME280_ADDR, &reg, 1, true);
    i2c_read_blocking(i2c0, BME280_ADDR, data, 8, false);

    int32_t adc_p = (data[0] << 12) | (data[1] << 4) | (data[2] >> 4);
    int32_t adc_t = (data[3] << 12) | (data[4] << 4) | (data[5] >> 4);
    int32_t adc_h = (data[6] << 8) | data[7];

    // Temperature compensation
    int32_t var1 = ((((adc_t >> 3) - ((int32_t)dig_T1 << 1))) * dig_T2) >> 11;
    int32_t var2 = (((((adc_t >> 4) - (int32_t)dig_T1) * ((adc_t >> 4) - (int32_t)dig_T1)) >> 12) * dig_T3) >> 14;
    t_fine = var1 + var2;
    *temperature = (t_fine * 5 + 128) >> 8;
    *temperature /= 100.0f;

    // Pressure compensation
    int64_t var1_p = (int64_t)t_fine - 128000;
    int64_t var2_p = var1_p * var1_p * (int64_t)dig_P6;
    var2_p = var2_p + ((var1_p * (int64_t)dig_P5) << 17);
    var2_p = var2_p + (((int64_t)dig_P4) << 35);
    var1_p = ((var1_p * var1_p * (int64_t)dig_P3) >> 8) + ((var1_p * (int64_t)dig_P2) << 12);
    var1_p = (((((int64_t)1) << 47) + var1_p)) * (int64_t)dig_P1 >> 33;

    int64_t p = 1048576 - adc_p;
    p = (((p << 31) - var2_p) * 3125) / var1_p;
    var1_p = ((int64_t)dig_P9 * (p >> 13) * (p >> 13)) >> 25;
    var2_p = ((int64_t)dig_P8 * p) >> 19;
    p = ((p + var1_p + var2_p) >> 8) + (((int64_t)dig_P7) << 4);

    *pressure = p / 25600.0f; // hPa

    // Humidity compensation
    int32_t v_x1 = (t_fine - ((int32_t)76800));
    v_x1 = (((((adc_h << 14) - (((int32_t)dig_H4) << 20) - (((int32_t)dig_H5) * v_x1)) +
              ((int32_t)16384)) >> 15) *
            (((((((v_x1 * ((int32_t)dig_H6)) >> 10) *
                 (((v_x1 * ((int32_t)dig_H3)) >> 11) + ((int32_t)32768))) >> 10) +
               ((int32_t)2097152)) * ((int32_t)dig_H2) + 8192) >> 14));
    v_x1 = v_x1 - (((((v_x1 >> 15) * (v_x1 >> 15)) >> 7) * ((int32_t)dig_H1)) >> 4);
    v_x1 = (v_x1 < 0 ? 0 : v_x1);
    v_x1 = (v_x1 > 419430400 ? 419430400 : v_x1);
    *humidity = (v_x1 >> 12) / 1024.0f;
}

int main() {
    stdio_init_all();
    i2c_init(i2c0, 100 * 1000);
    gpio_set_function(4, GPIO_FUNC_I2C);
    gpio_set_function(5, GPIO_FUNC_I2C);
    gpio_pull_up(4);
    gpio_pull_up(5);

    read_calibration();
    bme280_init();

    while (1) {
        float t, p, h;
        read_data(&t, &p, &h);
        printf("Temperature: %.2f C  Pressure: %.2f hPa  Humidity: %.2f %%\n", t, p, h);
        sleep_ms(1000);
    }
}
```
