
## BMP390

1. Read the calibration coefficients from the NVM registers.
2. Parse them into signed/unsigned integers as defined in the datasheet.
3. Apply Bosch’s equations for temperature and pressure compensation.


### MicroPython (full BMP390 compensation)

```python
from machine import Pin, I2C
import time

BMP390_ADDR = 0x77
REG_CHIP_ID = 0x00
REG_CALIB_DATA = 0x31
REG_CMD = 0x7E
REG_PWR_CTRL = 0x1B
REG_PRESS_MSB = 0x04

BMP390_ID = 0x60

i2c = I2C(0, scl=Pin(5), sda=Pin(4), freq=400000)

def read_reg(addr, nbytes=1):
    return i2c.readfrom_mem(BMP390_ADDR, addr, nbytes)

def write_reg(addr, data):
    i2c.writeto_mem(BMP390_ADDR, addr, bytes([data]))

# -- Initialise --
chip_id = read_reg(REG_CHIP_ID)[0]
if chip_id != BMP390_ID:
    raise Exception("BMP390 not found!")

write_reg(REG_CMD, 0xB6)  # soft reset
time.sleep(0.01)
write_reg(REG_PWR_CTRL, 0x30)  # enable temp + press

# -- Calibration --
calib = read_reg(REG_CALIB_DATA, 21)

par_t1 = int.from_bytes(calib[0:2], 'little')
par_t2 = int.from_bytes(calib[2:4], 'little', signed=True)
par_t3 = calib[4]

par_p1 = int.from_bytes(calib[5:7], 'little', signed=True)
par_p2 = int.from_bytes(calib[7:9], 'little', signed=True)
par_p3 = calib[9]
par_p4 = calib[10]
par_p5 = int.from_bytes(calib[11:13], 'little', signed=True)
par_p6 = int.from_bytes(calib[13:15], 'little', signed=True)
par_p7 = calib[15]
par_p8 = calib[16]
par_p9 = int.from_bytes(calib[17:19], 'little', signed=True)
par_p10 = calib[19]
par_p11 = calib[20]

# Scaling (datasheet table 24)
par_t1 = par_t1 / 2**8
par_t2 = par_t2 / 2**30
par_t3 = par_t3 / 2**48

par_p1 = (par_p1 - 2**14) / 2**20
par_p2 = (par_p2 - 2**14) / 2**29
par_p3 = par_p3 / 2**32
par_p4 = par_p4 / 2**37
par_p5 = par_p5 / 2**-3
par_p6 = par_p6 / 2**6
par_p7 = par_p7 / 2**8
par_p8 = par_p8 / 2**15
par_p9 = par_p9 / 2**48
par_p10 = par_p10 / 2**48
par_p11 = par_p11 / 2**65

t_lin = 0.0  # global linearised temp

def compensate_temp(adc_t):
    global t_lin
    partial = (adc_t / 2**20 - par_t1)
    t_lin = partial * par_t2 + partial * partial * par_t3
    return t_lin * 100.0  # °C

def compensate_press(adc_p):
    pd1 = par_p6 * t_lin
    pd2 = par_p7 * t_lin**2
    pd3 = par_p8 * t_lin**3
    poff = par_p5 + pd1 + pd2 + pd3

    ps1 = par_p1 + par_p2 * t_lin
    ps2 = par_p3 + par_p4 * t_lin
    ph = ps1 + ps2 * (adc_p / 2**20)

    pr = (adc_p / 2**20) * ph + poff
    pr += par_p9 * (adc_p / 2**20)**2 + par_p10 * (adc_p / 2**20)**3
    pr += (adc_p / 2**20)**4 * par_p11
    return pr / 100.0  # hPa

def read_raw():
    data = read_reg(REG_PRESS_MSB, 6)
    adc_p = data[0] | (data[1] << 8) | (data[2] << 16)
    adc_t = data[3] | (data[4] << 8) | (data[5] << 16)
    return adc_t, adc_p

# -- Main loop --
while True:
    adc_t, adc_p = read_raw()
    temp = compensate_temp(adc_t)
    press = compensate_press(adc_p)
    print("Temperature: {:.2f} °C, Pressure: {:.2f} hPa".format(temp, press))
    time.sleep(1)
```



### C (Pico SDK, full BMP390 compensation)

```c
#include "pico/stdlib.h"
#include "hardware/i2c.h"
#include <stdio.h>
#include <math.h>

#define I2C_PORT i2c0
#define BMP390_ADDR 0x77
#define REG_CHIP_ID 0x00
#define REG_CALIB_DATA 0x31
#define REG_CMD 0x7E
#define REG_PWR_CTRL 0x1B
#define REG_PRESS_MSB 0x04
#define BMP390_ID 0x60

// Global coefficients
double par_t1, par_t2, par_t3;
double par_p1, par_p2, par_p3, par_p4, par_p5;
double par_p6, par_p7, par_p8, par_p9, par_p10, par_p11;
double t_lin;

void i2c_write_reg(uint8_t reg, uint8_t val) {
    uint8_t buf[2] = {reg, val};
    i2c_write_blocking(I2C_PORT, BMP390_ADDR, buf, 2, false);
}

void i2c_read_reg(uint8_t reg, uint8_t *buf, size_t len) {
    i2c_write_blocking(I2C_PORT, BMP390_ADDR, &reg, 1, true);
    i2c_read_blocking(I2C_PORT, BMP390_ADDR, buf, len, false);
}

void read_calibration() {
    uint8_t calib[21];
    i2c_read_reg(REG_CALIB_DATA, calib, 21);

    int16_t tmp16;
    uint16_t tmpu16;
    int8_t tmp8;
    uint8_t tmpu8;

    tmpu16 = (uint16_t)(calib[0] | (calib[1] << 8));
    par_t1 = (double)tmpu16 / pow(2,8);
    tmp16 = (int16_t)(calib[2] | (calib[3] << 8));
    par_t2 = (double)tmp16 / pow(2,30);
    tmp8 = (int8_t)calib[4];
    par_t3 = (double)tmp8 / pow(2,48);

    tmp16 = (int16_t)(calib[5] | (calib[6] << 8));
    par_p1 = ((double)tmp16 - pow(2,14)) / pow(2,20);
    tmp16 = (int16_t)(calib[7] | (calib[8] << 8));
    par_p2 = ((double)tmp16 - pow(2,14)) / pow(2,29);
    tmpu8 = calib[9];
    par_p3 = (double)tmpu8 / pow(2,32);
    tmpu8 = calib[10];
    par_p4 = (double)tmpu8 / pow(2,37);
    tmp16 = (int16_t)(calib[11] | (calib[12] << 8));
    par_p5 = (double)tmp16 / pow(2,-3);
    tmp16 = (int16_t)(calib[13] | (calib[14] << 8));
    par_p6 = (double)tmp16 / pow(2,6);
    tmpu8 = calib[15];
    par_p7 = (double)tmpu8 / pow(2,8);
    tmpu8 = calib[16];
    par_p8 = (double)tmpu8 / pow(2,15);
    tmp16 = (int16_t)(calib[17] | (calib[18] << 8));
    par_p9 = (double)tmp16 / pow(2,48);
    tmp8 = (int8_t)calib[19];
    par_p10 = (double)tmp8 / pow(2,48);
    tmp8 = (int8_t)calib[20];
    par_p11 = (double)tmp8 / pow(2,65);
}

double compensate_temp(uint32_t adc_t) {
    double partial = ((double)adc_t / pow(2,20)) - par_t1;
    t_lin = partial * par_t2 + partial * partial * par_t3;
    return t_lin * 100.0; // °C
}

double compensate_press(uint32_t adc_p) {
    double pd1 = par_p6 * t_lin;
    double pd2 = par_p7 * pow(t_lin, 2);
    double pd3 = par_p8 * pow(t_lin, 3);
    double poff = par_p5 + pd1 + pd2 + pd3;

    double ps1 = par_p1 + par_p2 * t_lin;
    double ps2 = par_p3 + par_p4 * t_lin;
    double ph = ps1 + ps2 * (adc_p / pow(2,20));

    double pr = (adc_p / pow(2,20)) * ph + poff;
    pr += par_p9 * pow(adc_p / pow(2,20), 2);
    pr += par_p10 * pow(adc_p / pow(2,20), 3);
    pr += par_p11 * pow(adc_p / pow(2,20), 4);
    return pr / 100.0; // hPa
}

int main() {
    stdio_init_all();
    i2c_init(I2C_PORT, 400*1000);
    gpio_set_function(4, GPIO_FUNC_I2C);
    gpio_set_function(5, GPIO_FUNC_I2C);
    gpio_pull_up(4);
    gpio_pull_up(5);

    uint8_t id;
    i2c_read_reg(REG_CHIP_ID, &id, 1);
    if (id != BMP390_ID) {
        printf("BMP390 not found!\n");
        return -1;
    }

    i2c_write_reg(REG_CMD, 0xB6); // reset
    sleep_ms(10);
    i2c_write_reg(REG_PWR_CTRL, 0x30);

    read_calibration();

    while (1) {
        uint8_t buf[6];
        i2c_read_reg(REG_PRESS_MSB, buf, 6);
        uint32_t adc_p = buf[0] | (buf[1] << 8) | (buf[2] << 16);
        uint32_t adc_t = buf[3] | (buf[4] << 8) | (buf[5] << 16);

        double temp = compensate_temp(adc_t);
        double press = compensate_press(adc_p);

        printf("T = %.2f °C, P = %.2f hPa\n", temp, press);
        sleep_ms(1000);
    }
}
```


### Barometric altitude — formula and notes

A common and practical approximation for altitude from pressure
is the international barometric formula:
```
    h = 44330.0 * (1.0 - (P / P0) ** (1.0 / 5.255))
```
where:
- `h` is altitude in metres,
- `P` is measured pressure in hPa,
- `P0` is reference sea-level pressure in hPa (default 1013.25 hPa).

Notes:
- Using the local current sea-level pressure (P0) gives far better altitude
  accuracy than the default 1013.25 hPa.
- This formula assumes a standard atmosphere and is suitable for typical
  hobbyist/weather uses. For precise elevation measurements you need local
  meteorological corrections.


### MicroPython: altitude function (drop into the BMP390 MicroPython code above)

Returns altitude in metres from pressure (hPa).
- p_hpa: measured pressure in hPa (e.g., value returned by compensate_press)
- p0_hpa: reference sea-level pressure in hPa (default 1013.25)
```python
def altitude_from_pressure(p_hpa, p0_hpa=1013.25):
    # Avoid division by zero or negative pressures
    if p_hpa <= 0:
        return None
    return 44330.0 * (1.0 - (p_hpa / p0_hpa) ** (1.0 / 5.255))
```

Example usage in the main loop (after you compute `press` in hPa):
```python
p0 = 1013.25  # or set to local sea-level pressure
alt = altitude_from_pressure(press, p0)
print("Altitude: {:.2f} m".format(alt))
```

### C (Pico SDK): altitude function (drop into the BMP390 C code above)

```c
#include <math.h>

/* 
 * Compute altitude in metres from pressure in hPa.
 * p_hpa: measured pressure in hPa
 * p0_hpa: reference sea-level pressure in hPa (default 1013.25)
 */
double altitude_from_pressure(double p_hpa, double p0_hpa) {
    if (p_hpa <= 0.0) return NAN;
    return 44330.0 * (1.0 - pow(p_hpa / p0_hpa, 1.0 / 5.255));
}

/* Example usage after you compute `press` (in hPa):
 * double p0 = 1013.25; // or local sea-level pressure
 * double alt = altitude_from_pressure(press, p0);
 * printf("Altitude: %.2f m\n", alt);
 */
```




### Early aviation and "analog computers"

Before digital electronics, aircraft often relied on mechanical or analog computing
devices to derive altitude, airspeed, bombing trajectories, or firing solutions.

Barometric altitude (like the BMP390) was originally measured using a
*mechanical aneroid barometer*:
- A sealed metal capsule would expand/contract with changes in air pressure.
- That mechanical movement would drive gears and dials--giving a direct altitude readout.
- In principle, it was performing the same function as our formula:
  mapping air pressure to height, assuming a standard atmosphere.


#### Military applications (WWI–WWII era and after)

1. Altimeters:
- Standard aircraft altimeters were essentially analog computers for pressure.
- They assumed sea-level pressure = 1013.25 hPa unless the pilot adjusted the
  "Kollsman window" for local barometric pressure.
- Errors occurred if weather changed or if pressure wasn’t set correctly.

2. Airspeed indicators:
- These also used pressure, comparing pitot tube (dynamic pressure) with
  static pressure from a port.
- The difference was mechanically converted into speed.

3. Bombsights & fire-control computers:
- Devices like the Norden bombsight in WWII combined barometric altitude,
  airspeed, wind correction, and ballistics in a purely analog way.
- Inside, there were gears, cams, and mechanical integrators that solved
  differential equations in real time--all based on continuous mechanical movement.

4. Naval and artillery fire-control computers:
- Similar technology but more elaborate: large electro-mechanical devices that
  continuously computed shell trajectories given bearing, range, wind, and ship motion.


#### Parallel with the BMP390 project

Reading pressure and turning it into altitude with an equation is exactly what those
early instruments did with springs, gears, and cams.
- The BMP390’s silicon diaphragm is the equivalent of the old aneroid capsule.
- THe compensation math is what used to be embodied in carefully designed mechanical linkages.
- The difference is that now you can run it in digital code at kilohertz speeds and with
  much greater precision.
