
## Projects on Paradigms


__1. Implement the Same Program in Multiple Paradigms__

Write a simple application (e.g. a calculator, maze solver, or expression evaluator) in at
least three different programming paradigms (e.g. imperative, functional, and declarative).
Compare the readability, maintainability, and efficiency of each version.

Question to explore:
- How does each paradigm change the way you reason about the problem?
- Which paradigm feels the most intuitive for the task, and why?


__2. Build a Small Language or DSL (Domain-Specific Language)__

Design a tiny programming language or DSL tailored for a specific task, such as data filtering,
task automation, or procedural art. You can implement an interpreter or a compiler for it.

Question to explore:
- How do language features and constraints enforce a specific paradigm?
- What design choices make a language lean toward imperative, functional, or declarative styles?


__3. Parallelism and Concurrency: Test Amdahl's Law__

Write a program that performs a computationally expensive task (e.g. image processing, matrix
multiplication, or pathfinding) and implement parallel and sequential versions. Use different
approaches such as threads, async programming, or message passing.

Question to explore:
- How much speedup do you get as you add more processors/threads?
- Where does Amdahl's Law become a limiting factor?


__4. Implement a Mini Prolog or Logic-Based System__

Implement a basic rule-based system (e.g. a simplified Prolog-like interpreter) that solves
logical queries. Focus on pattern matching, backtracking, and inference rules.

Question to explore:
- How does declarative programming fundamentally shift how you structure solutions?
- What kinds of problems are easier or harder to express compared to procedural code?


__5. Refactor a Large Imperative Codebase into a Functional One__

Take an existing imperative-style program (perhaps one you wrote earlier) and rewrite it
using functional programming techniques. Eliminate mutable state and side effects where possible.

Question to explore:
- What challenges arise when moving from a stateful to a stateless approach?
- What advantages do you gain in terms of testability and correctness?


__6. Design Patterns in Different Paradigms__

Choose a well-known design pattern (e.g. Observer, Strategy, or Factory) and implement it in
different paradigms. Compare an object-oriented approach vs. a functional or declarative approach.

Question to explore:
- Which patterns adapt well to functional programming?
- Are some patterns unnecessary in certain paradigms?


__7. Self-Modifying Code and Metaprogramming__

Write a program that writes or modifies its own code at runtime. You can explore macros, AST
(Abstract Syntax Trees), or runtime code generation.

Question to explore:
- How do different paradigms support or restrict metaprogramming?
- Where is self-modifying code useful, and where is it a liability?


__8. Theoretical Limitations and Computability__

Investigate problems that are provably undecidable (e.g. the Halting Problem, Post Correspondence
Problem, or Gödel's incompleteness theorems). Write a program that approximates a solution to an
undecidable problem.

Question to explore:
- Can you design a practical heuristic that works well in most cases?
- How does understanding the limits of computation affect real-world programming?


__9. Exploring Programming Paradigms Through a Unified Problem__

Investigate how different programming paradigms (functional, object-oriented, procedural, logic,
event-driven, aspect-oriented, etc.) affect the design and implementation of the same problem.
Choose a moderately complex problem (e.g. a rule-based chatbot, a physics simulation, or a game
like Conway’s Game of Life) and implement it in at least three distinct paradigms.

Questions to explore:
- How does the structure of the solution change across paradigms?
- What are the strengths and weaknesses of each paradigm for this problem?
- Can some paradigms be combined to leverage their advantages?
- How does the computational model (e.g. declarative vs. imperative, synchronous vs. asynchronous)
influence the implementation?


__10. Computational Styles and Performance Trade-offs__

Investigate how different computational styles (array computing, dataflow programming, reactive
programming, concurrent vs. parallel programming) affect performance and readability. Implement
a problem such as a matrix multiplication, a streaming data pipeline, or a live sensor-based
dashboard using different computational styles.

Questions to explore:
- How do the implementations differ in terms of conciseness, maintainability, and correctness?
- Which styles are more naturally suited for different types of hardware (e.g. CPU, GPU,
  distributed systems)?
- How does choosing a computational style impact scalability and performance optimizations?
- What trade-offs exist between clarity and execution efficiency?
