
## Projects on Paradigms


__1. Implement the Same Program in Multiple Paradigms__

Write a simple application (e.g. a calculator, maze solver, or expression evaluator) in at
least three different programming paradigms (e.g. imperative, functional, and declarative).
Compare the readability, maintainability, and efficiency of each version.

Question to explore:
- How does each paradigm change the way you reason about the problem?
- Which paradigm feels the most intuitive for the task, and why?


__2. Build a Small Language or DSL (Domain-Specific Language)__

Design a tiny programming language or DSL tailored for a specific task, such as data filtering,
task automation, or procedural art. You can implement an interpreter or a compiler for it.

Question to explore:
- How do language features and constraints enforce a specific paradigm?
- What design choices make a language lean toward imperative, functional, or declarative styles?


__3. Parallelism and Concurrency: Test Amdahl's Law__

Write a program that performs a computationally expensive task (e.g. image processing, matrix
multiplication, or pathfinding) and implement parallel and sequential versions. Use different
approaches such as threads, async programming, or message passing.

Question to explore:
- How much speedup do you get as you add more processors/threads?
- Where does Amdahl's Law become a limiting factor?


__4. Implement a Mini Prolog or Logic-Based System__

Implement a basic rule-based system (e.g. a simplified Prolog-like interpreter) that solves
logical queries. Focus on pattern matching, backtracking, and inference rules.

Question to explore:
- How does declarative programming fundamentally shift how you structure solutions?
- What kinds of problems are easier or harder to express compared to procedural code?


__5. Refactor a Large Imperative Codebase into a Functional One__

Take an existing imperative-style program (perhaps one you wrote earlier) and rewrite it
using functional programming techniques. Eliminate mutable state and side effects where possible.

Question to explore:
- What challenges arise when moving from a stateful to a stateless approach?
- What advantages do you gain in terms of testability and correctness?


__6. Design Patterns in Different Paradigms__

Choose a well-known design pattern (e.g. Observer, Strategy, or Factory) and implement it in
different paradigms. Compare an object-oriented approach vs. a functional or declarative approach.

Question to explore:
- Which patterns adapt well to functional programming?
- Are some patterns unnecessary in certain paradigms?


__7. Self-Modifying Code and Metaprogramming__

Write a program that writes or modifies its own code at runtime. You can explore macros, AST
(Abstract Syntax Trees), or runtime code generation.

Question to explore:
- How do different paradigms support or restrict metaprogramming?
- Where is self-modifying code useful, and where is it a liability?


__8. Theoretical Limitations and Computability__

Investigate problems that are provably undecidable (e.g. the Halting Problem, Post Correspondence
Problem, or GÃ¶del's incompleteness theorems). Write a program that approximates a solution to an
undecidable problem.

Question to explore:
- Can you design a practical heuristic that works well in most cases?
- How does understanding the limits of computation affect real-world programming?
