<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LIBRIS Xsearch with RAG</title>
    <style>
        body { 
            font-family: Arial, sans-serif; 
            padding: 20px; 
            max-width: 1000px;
            margin: 0 auto;
            line-height: 1.6;
        }
        h2 {
            color: #005A9C;
            border-bottom: 2px solid #eee;
            padding-bottom: 10px;
        }
        .search-container {
            background-color: #f9f9f9;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .form-group {
            margin-bottom: 15px;
            display: flex;
            flex-wrap: wrap;
            align-items: center;
        }
        label {
            font-weight: bold;
            margin-right: 10px;
            min-width: 120px;
        }
        input, select { 
            padding: 10px; 
            border: 1px solid #ddd;
            border-radius: 4px;
            flex-grow: 1;
            max-width: 400px;
        }
        .buttons-container {
            margin-top: 20px;
            display: flex;
            gap: 10px;
        }
        button {
            padding: 10px 15px;
            background-color: #005A9C;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #003D6B;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        button.secondary {
            background-color: #6c757d;
        }
        button.secondary:hover {
            background-color: #5a6268;
        }
        .pagination {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 20px;
            padding: 10px 0;
            border-top: 1px solid #eee;
        }
        .pagination-info {
            font-style: italic;
            color: #666;
        }
        #results {
            margin-top: 20px;
        }
        .result-item {
            border-bottom: 1px solid #eee;
            padding: 10px 0;
            margin-bottom: 10px;
        }
        .result-title {
            font-weight: bold;
            color: #005A9C;
            margin-bottom: 5px;
        }
        .result-meta {
            font-size: 0.9em;
            color: #666;
        }
        .loading {
            text-align: center;
            padding: 20px;
            font-style: italic;
            color: #666;
        }
        .hidden {
            display: none;
        }
        .xml-view {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 4px;
            overflow: auto;
            font-family: monospace;
            font-size: 14px;
            margin-bottom: 15px;
            border: 1px solid #ddd;
        }
        .xml-toggle {
            color: #005A9C;
            text-decoration: underline;
            cursor: pointer;
            font-size: 0.9em;
            margin-bottom: 10px;
            display: inline-block;
        }
        .xml-toggle:hover {
            color: #003D6B;
        }
        .citation-item {
            margin-bottom: 15px;
            padding: 10px;
            background-color: #f5f5f5;
            border-left: 3px solid #005A9C;
        }
        .rag-toggle {
            margin-top: 10px;
        }
        .similarity-score {
            font-size: 0.8em;
            color: #888;
            margin-left: 10px;
        }
        .error-message {
            color: #d32f2f;
            font-style: italic;
            padding: 10px;
        }
        .model-status {
            font-size: 0.9em;
            color: #666;
            margin-top: 5px;
        }
        .model-loading {
            color: #f57c00;
        }
        .model-ready {
            color: #2e7d32;
        }
        .model-error {
            color: #d32f2f;
        }
    </style>
</head>
<body>
    <h2>LIBRIS Xsearch API with RAG</h2>

    <div class="search-container">
        <div class="form-group">
            <label for="query">Search Query:</label>
            <input type="text" id="query" placeholder="Enter search term">
        </div>

        <div class="form-group">
            <label for="format">Format:</label>
            <select id="format">
                <option value="json">JSON</option>
                <option value="bibtex">Bibtex</option>
                <option value="oxford">Oxford</option>
                <option value="harvard">Harvard</option>
                <option value="refworks">Refworks</option>
                <option value="marcxml">MARC-XML</option>
                <option value="mods">MODS</option>
                <option value="ris">RIS</option>
                <option value="dc">Dublin Core</option>
                <option value="rdfdc">RDF + Dublin Core</option>
            </select>
        </div>

        <div class="buttons-container">
            <button id="searchBtn" onclick="searchLibris(true)">Search</button>
            <button id="resetBtn" class="secondary" onclick="resetSearch()">Reset</button>
        </div>
        <div class="form-group rag-toggle">
            <label for="useRag">Use RAG Ranking:</label>
            <input type="checkbox" id="useRag" checked>
            <div id="modelStatus" class="model-status model-loading">Loading RAG model...</div>
        </div>
    </div>

    <div id="loading" class="loading hidden">Searching LIBRIS database...</div>
    <div id="error" class="error-message hidden"></div>

    <div id="resultsContainer" class="hidden">
        <h3>Results</h3>
        <div id="resultsStats"></div>
        <div id="results"></div>

        <div class="pagination">
            <div>
                <button id="prevBtn" disabled onclick="changePage(-pageSize)">Previous</button>
                <button id="nextBtn" disabled onclick="changePage(pageSize)">Next</button>
            </div>
            <div class="pagination-info" id="paginationInfo"></div>
        </div>
    </div>

    <script type="module">
        import { pipeline, env } from 'https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.2/dist/transformers.min.js';
        
        // Configure environment
        env.allowRemoteModels = true;
        env.allowLocalModels = false;

        let start = 1;
        const pageSize = 10;
        let totalRecords = 0;
        let currentQuery = "";
        let transformerModel = null;
        let vectorStore = [];
        let modelLoading = false;

        // Make functions globally available
        window.searchLibris = searchLibris;
        window.resetSearch = resetSearch;
        window.changePage = changePage;

        // Display error message
        function showError(message) {
            const errorDiv = document.getElementById("error");
            errorDiv.textContent = message;
            errorDiv.classList.remove("hidden");
        }

        // Clear error message
        function clearError() {
            const errorDiv = document.getElementById("error");
            errorDiv.textContent = "";
            errorDiv.classList.add("hidden");
        }

        // Update model status display
        function updateModelStatus(status, message) {
            const statusDiv = document.getElementById("modelStatus");
            statusDiv.className = `model-status model-${status}`;
            statusDiv.textContent = message;
        }

        // Load the transformer model
        async function loadModel() {
            if (modelLoading) return;
            modelLoading = true;
            
            try {
                updateModelStatus('loading', 'Loading RAG model...');
                transformerModel = await pipeline(
                    'feature-extraction',
                    'Xenova/all-MiniLM-L6-v2'
                );
                updateModelStatus('ready', 'RAG model ready');
                console.log("Model loaded successfully");
            } catch (error) {
                console.error("Error loading model:", error);
                updateModelStatus('error', 'RAG model failed to load');
                showError("Failed to load RAG model. RAG ranking disabled.");
                document.getElementById("useRag").disabled = true;
                document.getElementById("useRag").checked = false;
                transformerModel = null;
            } finally {
                modelLoading = false;
            }
        }

        // Generate embedding for a text
        async function getEmbedding(text) {
            if (!transformerModel) {
                console.warn("Transformer model not available");
                return null;
            }
            try {
                const cleanText = text.replace(/\s+/g, ' ').trim();
                if (!cleanText) return null;
                
                const output = await transformerModel(cleanText, { 
                    pooling: 'mean', 
                    normalize: true 
                });
                return Array.from(output.data);
            } catch (error) {
                console.error("Error generating embedding:", error);
                return null;
            }
        }

        // Compute cosine similarity
        function cosineSimilarity(vecA, vecB) {
            if (!vecA || !vecB || vecA.length !== vecB.length) return 0;
            try {
                const dotProduct = vecA.reduce((sum, a, i) => sum + a * vecB[i], 0);
                const magnitudeA = Math.sqrt(vecA.reduce((sum, a) => sum + a * a, 0));
                const magnitudeB = Math.sqrt(vecB.reduce((sum, b) => sum + b * b, 0));
                if (magnitudeA === 0 || magnitudeB === 0) return 0;
                return dotProduct / (magnitudeA * magnitudeB);
            } catch (error) {
                console.error("Error computing cosine similarity:", error);
                return 0;
            }
        }

        // Add event listener for Enter key
        document.getElementById("query").addEventListener("keyup", function(event) {
            if (event.key === "Enter") {
                searchLibris(true);
            }
        });

        async function searchLibris(reset = false) {
            let query = document.getElementById("query").value.trim();
            let format = document.getElementById("format").value;
            let useRag = document.getElementById("useRag").checked;

            if (!query) {
                showError("Please enter a search term.");
                return;
            }

            if (reset) {
                start = 1;
                currentQuery = query;
                vectorStore = [];
            }

            clearError();
            document.getElementById("loading").classList.remove("hidden");
            document.getElementById("resultsContainer").classList.add("hidden");
            document.getElementById("searchBtn").disabled = true;

            let apiUrl = `https://libris.kb.se/xsearch?query=${encodeURIComponent(query)}&format=${format}&start=${start}&n=${pageSize}`;

            try {
                const response = await fetch(apiUrl, { mode: 'cors' });
                if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);

                const totalCountHeader = response.headers.get("X-Total-Count");
                if (totalCountHeader) {
                    totalRecords = parseInt(totalCountHeader);
                }

                const contentType = response.headers.get("content-type");
                let data, rawContent;
                if (contentType && contentType.includes("application/json")) {
                    data = await response.json();
                } else {
                    rawContent = await response.text();
                }

                document.getElementById("loading").classList.add("hidden");
                document.getElementById("resultsContainer").classList.remove("hidden");

                if (data && data.xsearch && data.xsearch.records !== undefined) {
                    totalRecords = parseInt(data.xsearch.records);
                    if (useRag && transformerModel) {
                        try {
                            await processRagResults(data.xsearch.list || [], query);
                        } catch (error) {
                            console.error("RAG processing failed:", error);
                            showError("RAG ranking failed, showing default results.");
                            displayResults(data.xsearch.list || []);
                        }
                    } else {
                        displayResults(data.xsearch.list || []);
                    }
                    updatePagination();
                } else if (rawContent) {
                    displayFormattedContent(rawContent, format);
                    updatePagination();
                } else {
                    document.getElementById("results").innerHTML = "<div class='result-item'>No results found.</div>";
                    document.getElementById("resultsStats").textContent = "0 results found";
                    totalRecords = 0;
                    updatePagination();
                }

                document.getElementById("searchBtn").disabled = false;
            } catch (error) {
                console.error("Search error:", error);
                document.getElementById("loading").classList.add("hidden");
                document.getElementById("resultsContainer").classList.remove("hidden");
                showError(`Error fetching data: ${error.message}`);
                document.getElementById("resultsStats").textContent = "Error occurred";
                document.getElementById("searchBtn").disabled = false;
            }
        }

        async function processRagResults(records, query) {
            if (!transformerModel) {
                console.warn("Transformer model not available for RAG processing");
                displayResults(records);
                return;
            }

            vectorStore = [];
            updateModelStatus('loading', 'Processing with RAG...');
            
            try {
                const queryEmbedding = await getEmbedding(query);
                if (!queryEmbedding) {
                    console.warn("Failed to generate query embedding, falling back to default results");
                    displayResults(records);
                    return;
                }

                const processedRecords = [];
                for (const record of records) {
                    const text = [
                        record.title || '',
                        record.creator || '',
                        record.description || '',
                        record.subject || '',
                        record.type || ''
                    ].filter(Boolean).join(' ');
                    
                    const embedding = await getEmbedding(text);
                    const similarity = embedding ? cosineSimilarity(queryEmbedding, embedding) : 0;
                    processedRecords.push({ record, embedding, similarity });
                }

                // Sort by similarity score
                processedRecords.sort((a, b) => b.similarity - a.similarity);
                vectorStore = processedRecords;
                
                displayResults(processedRecords.map(item => item.record), processedRecords);
                updateModelStatus('ready', 'RAG model ready');
            } catch (error) {
                console.error("RAG processing error:", error);
                displayResults(records);
                updateModelStatus('error', 'RAG processing failed');
            }
        }

        function displayResults(records, vectorStore = null) {
            let resultsDiv = document.getElementById("results");
            resultsDiv.innerHTML = "";

            if (!records || records.length === 0) {
                resultsDiv.innerHTML = "<div class='result-item'>No results found.</div>";
                document.getElementById("resultsStats").textContent = "0 results found";
                return;
            }

            const ragInfo = vectorStore ? " (RAG ranked)" : "";
            document.getElementById("resultsStats").textContent = 
                `Showing ${start} - ${Math.min(start + records.length - 1, totalRecords)} of ${totalRecords} results${ragInfo}`;

            records.forEach((record, index) => {
                let item = document.createElement("div");
                item.className = "result-item";

                let title = document.createElement("div");
                title.className = "result-title";
                title.textContent = record.title || "No title available";
                
                if (vectorStore && vectorStore[index] && vectorStore[index].similarity > 0) {
                    const scoreSpan = document.createElement("span");
                    scoreSpan.className = "similarity-score";
                    scoreSpan.textContent = `(Similarity: ${vectorStore[index].similarity.toFixed(3)})`;
                    title.appendChild(scoreSpan);
                }
                item.appendChild(title);

                let meta = document.createElement("div");
                meta.className = "result-meta";
                let metaText = [];
                if (record.creator) metaText.push(`Author: ${record.creator}`);
                if (record.date) metaText.push(`Date: ${record.date}`);
                if (record.type) metaText.push(`Type: ${record.type}`);
                if (record.identifier) metaText.push(`ID: ${record.identifier}`);
                meta.textContent = metaText.join(" | ");
                if (metaText.length > 0) {
                    item.appendChild(meta);
                }

                resultsDiv.appendChild(item);
            });
        }

        function displayFormattedContent(content, format) {
            let resultsDiv = document.getElementById("results");
            resultsDiv.innerHTML = "";

            if (format === "marcxml" || format === "mods") {
                try {
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(content, "text/xml");
                    const parserErrors = xmlDoc.getElementsByTagName("parsererror");
                    if (parserErrors.length > 0) {
                        throw new Error("XML parsing error");
                    }

                    if (format === "marcxml") {
                        displayMarcXmlResults(xmlDoc, resultsDiv);
                    } else if (format === "mods") {
                        displayModsResults(xmlDoc, resultsDiv);
                    }

                    const toggle = document.createElement("div");
                    toggle.className = "xml-toggle";
                    toggle.textContent = "Show raw XML";
                    toggle.onclick = function() {
                        const rawPre = document.createElement("pre");
                        rawPre.className = "xml-view";
                        rawPre.textContent = formatXml(content);
                        if (this.textContent === "Show raw XML") {
                            resultsDiv.appendChild(rawPre);
                            this.textContent = "Hide raw XML";
                        } else {
                            resultsDiv.removeChild(resultsDiv.lastChild);
                            this.textContent = "Show raw XML";
                        }
                    };
                    resultsDiv.insertBefore(toggle, resultsDiv.firstChild);
                } catch (error) {
                    console.error("Error parsing XML:", error);
                    showError("Error parsing XML content, displaying raw content.");
                    displayRawContent(content, format);
                }
            } else if (format === "bibtex" || format === "oxford" || format === "harvard" || format === "refworks") {
                displayCitationResults(content, format);
            } else {
                displayRawContent(content, format);
            }

            document.getElementById("resultsStats").textContent = 
                `Showing ${start} - ${Math.min(start + pageSize - 1, totalRecords)} of ${totalRecords} results (${format.toUpperCase()})`;
        }

        function displayMarcXmlResults(xmlDoc, container) {
            const records = xmlDoc.getElementsByTagName("record");
            if (records.length === 0) {
                container.innerHTML = "<div class='result-item'>No records found in MARC-XML response.</div>";
                return;
            }

            for (let record of records) {
                const item = document.createElement("div");
                item.className = "result-item";

                const titleField = record.querySelector("datafield[tag='245']");
                let title = "No title available";
                if (titleField) {
                    const subfieldA = titleField.querySelector("subfield[code='a']");
                    const subfieldB = titleField.querySelector("subfield[code='b']");
                    title = (subfieldA ? subfieldA.textContent : "") + 
                           (subfieldB ? " " + subfieldB.textContent : "");
                }

                const authorField = record.querySelector("datafield[tag='100']");
                const author = authorField ? authorField.querySelector("subfield[code='a']")?.textContent : null;

                const dateField = record.querySelector("datafield[tag='260'], datafield[tag='264']");
                const date = dateField ? dateField.querySelector("subfield[code='c']")?.textContent : null;

                const idField = record.querySelector("controlfield[tag='001']");
                const id = idField ? idField.textContent : null;

                const titleEl = document.createElement("div");
                titleEl.className = "result-title";
                titleEl.textContent = title;
                item.appendChild(titleEl);

                const metaEl = document.createElement("div");
                metaEl.className = "result-meta";
                const metaText = [];
                if (author) metaText.push(`Author: ${author}`);
                if (date) metaText.push(`Date: ${date}`);
                if (id) metaText.push(`ID: ${id}`);
                metaEl.textContent = metaText.join(" | ");
                if (metaText.length > 0) {
                    item.appendChild(metaEl);
                }

                container.appendChild(item);
            }
        }

        function displayModsResults(xmlDoc, container) {
            const modsElements = xmlDoc.getElementsByTagNameNS("http://www.loc.gov/mods/v3", "mods") || 
                                xmlDoc.getElementsByTagName("mods");
            if (modsElements.length === 0) {
                container.innerHTML = "<div class='result-item'>No MODS records found.</div>";
                return;
            }

            for (let mods of modsElements) {
                const item = document.createElement("div");
                item.className = "result-item";

                const titleInfo = mods.querySelector("titleInfo");
                let title = "No title available";
                if (titleInfo) {
                    const titlePart = titleInfo.querySelector("title");
                    const nonSort = titleInfo.querySelector("nonSort");
                    title = (nonSort ? nonSort.textContent + " " : "") + 
                           (titlePart ? titlePart.textContent : "");
                }

                const nameElements = mods.querySelectorAll("name[nameRole='aut']");
                const authors = [];
                for (let name of nameElements) {
                    const namePart = name.querySelector("namePart");
                    if (namePart) authors.push(namePart.textContent);
                }

                const originInfo = mods.querySelector("originInfo");
                let date = null;
                if (originInfo) {
                    const dateIssued = originInfo.querySelector("dateIssued");
                    if (dateIssued) date = dateIssued.textContent;
                }

                const recordInfo = mods.querySelector("recordInfo");
                let id = null;
                if (recordInfo) {
                    const recordIdentifier = recordInfo.querySelector("recordIdentifier");
                    if (recordIdentifier) id = recordIdentifier.textContent;
                }

                const titleEl = document.createElement("div");
                titleEl.className = "result-title";
                titleEl.textContent = title;
                item.appendChild(titleEl);

                const metaEl = document.createElement("div");
                metaEl.className = "result-meta";
                const metaText = [];
                if (authors.length > 0) metaText.push(`Author(s): ${authors.join(", ")}`);
                if (date) metaText.push(`Date: ${date}`);
                if (id) metaText.push(`ID: ${id}`);
                metaEl.textContent = metaText.join(" | ");
                if (metaText.length > 0) {
                    item.appendChild(metaEl);
                }

                container.appendChild(item);
            }
        }

        function displayCitationResults(content, format) {
            const resultsDiv = document.getElementById("results");
            resultsDiv.innerHTML = "";

            let citations = [];
            try {
                if (format === "bibtex") {
                    citations = content.split(/(?=@)/).filter(c => c.trim());
                } else if (format === "refworks") {
                    citations = content.split(/\n\s*\n/).filter(c => c.trim());
                } else {
                    citations = content.split('\n').filter(c => c.trim());
                }
            } catch (error) {
                console.error("Error parsing citations:", error);
                showError("Error parsing citation content.");
                return;
            }

            if (citations.length === 0) {
                resultsDiv.innerHTML = "<div class='result-item'>No citations found.</div>";
                return;
            }

            citations.forEach(citation => {
                const item = document.createElement("div");
                item.className = "citation-item";

                if (format === "bibtex") {
                    const titleMatch = citation.match(/title\s*=\s*{([^}]*)}/i);
                    const title = titleMatch ? titleMatch[1] : "Untitled";
                    const titleEl = document.createElement("div");
                    titleEl.className = "result-title";
                    titleEl.textContent = title;
                    item.appendChild(titleEl);

                    const pre = document.createElement("pre");
                    pre.textContent = citation;
                    item.appendChild(pre);
                } else {
                    const pre = document.createElement("pre");
                    pre.textContent = citation;
                    item.appendChild(pre);
                }

                resultsDiv.appendChild(item);
            });
        }

        function displayRawContent(content, format) {
            let resultsDiv = document.getElementById("results");
            resultsDiv.innerHTML = "";

            let pre = document.createElement("pre");
            pre.className = "xml-view";
            try {
                if (format === "marcxml" || format === "mods") {
                    pre.textContent = formatXml(content);
                } else {
                    pre.textContent = content;
                }
            } catch (error) {
                console.error("Error formatting content:", error);
                pre.textContent = content;
            }
            resultsDiv.appendChild(pre);
        }

        function formatXml(xml) {
            try {
                let formatted = '';
                let indent = '';
                const tab = '  ';
                xml.split(/>\s*</).forEach(node => {
                    if (node.match(/^\/\w/)) {
                        indent = indent.substring(tab.length);
                    }
                    formatted += indent + '<' + node + '>\r\n';
                    if (node.match(/^<?\w[^>]*[^\/]$/) && !node.startsWith('?xml')) {
                        indent += tab;
                    }
                });
                return formatted.substring(1, formatted.length - 3);
            } catch (error) {
                console.error("Error formatting XML:", error);
                return xml;
            }
        }

        function updatePagination() {
            let prevBtn = document.getElementById("prevBtn");
            let nextBtn = document.getElementById("nextBtn");
            let paginationInfo = document.getElementById("paginationInfo");

            prevBtn.disabled = start <= 1;
            nextBtn.disabled = start + pageSize > totalRecords;

            if (totalRecords > 0) {
                const currentPage = Math.ceil(start / pageSize);
                const totalPages = Math.ceil(totalRecords / pageSize);
                paginationInfo.textContent = `Page ${currentPage} of ${totalPages}`;
            } else {
                paginationInfo.textContent = "No results";
            }
        }

        function changePage(offset) {
            start += offset;
            if (start < 1) start = 1;
            searchLibris(false);
        }

        function resetSearch() {
            document.getElementById("query").value = "";
            document.getElementById("format").selectedIndex = 0;
            document.getElementById("useRag").checked = true;
            document.getElementById("resultsContainer").classList.add("hidden");
            clearError();
            start = 1;
            totalRecords = 0;
            currentQuery = "";
            vectorStore = [];
            document.getElementById("query").focus();
        }

        // Initialize model on page load
        loadModel().catch(err => {
            console.error("Model initialization failed:", err);
        });

    </script>
</body>
</html>
