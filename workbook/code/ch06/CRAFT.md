
## Methods and tools

*Approaching programming as a 'craft' emphasizes a practical, skill-based, and iterative mastery that
combines precision, technique, and the development of personal style over time. Unlike the 'art' view,
which leans towards creativity and abstract design, or the 'science' view, which focuses on rigorous
methodology, the 'craft' perspective is rooted in hands-on skill development, often shared through
mentorship, apprenticeship, and iterative refinement.*


### Arguments for Programming as a Craft

Skill and Mastery Through Practice: Craftsmanship highlights the importance of practice and iterative
improvement. Like woodworking or metalworking, where skills improve through repetition and accumulated
experience, programming as a craft underscores the importance of honing one's abilities over time.
This is achieved through solving real problems, debugging, refactoring, and learning through trial and
error.

Focus on Practical Outcomes: Crafts are valued for their practical, tangible outcomes. In programming,
this translates to producing code that works reliably in the real world, fulfills its purpose, and can
be maintained and evolved. Practical utility is prioritized, and the process is grounded in producing
high-quality, working software.  

- *Emphasis on Code Quality and Maintainability.* In the same way a craftsperson aims to create items that
  endure and serve well, programmers focused on craft value clean, maintainable, and well-documented code.
  Craftsmanship in programming emphasizes longevity, where code can evolve without breaking and can be
  easily understood by others.

- *Personal Style and Adaptability.* Every craftsperson develops a personal style, built from preferences
  and techniques honed over time. In programming, this can mean adopting a specific way of structuring
  code, choosing certain tools or languages, or preferring particular design patterns. The craft approach
  values adaptability to different contexts, client needs, and team standards.

- *Mentorship and Apprenticeship Models.* Craftsmanship is often passed down through mentorship and
  apprenticeship, where knowledge and skills are directly transmitted from experienced practitioners
  to newcomers. This aligns well with pair programming, code reviews, and collaborative environments,
  where senior developers can guide and mentor juniors.


## Methods and practices for programming as a craft

### Code Reviews and Pair Programming

__Why__: Like a craftsperson learning by observing and working alongside a master, pair programming and
code reviews allow knowledge transfer and provide opportunities to refine techniques and improve code
quality.  

__How__: Regular code reviews should focus not only on correctness but also on style, efficiency, and
readability. Pair programming encourages immediate feedback and a shared understanding of coding
standards and problem-solving techniques.


### Iterative refactoring

__Why__: Refactoring is analogous to a craftsperson polishing or refining their work. It allows for continuous
improvement and adaptation of code to meet changing requirements or improve clarity and performance.  

__How__: Make refactoring a regular part of the development process. Focus on removing redundant code,
simplifying complex methods, and improving readability and maintainability. Tools like linting, static
analysis, and style guides can provide automated support.


### TDD and Small, Incremental Steps

__Why__: Test-Driven Development (TDD) is like building small components of a larger structure and verifying each one's quality before moving on. It reinforces disciplined programming and helps ensure reliability.  

__How__: Start with small, testable parts of functionality, write tests for them, and iteratively build and test larger components. This keeps code manageable and helps catch errors early.


### Building Personal Coding Standards and Style

Why: A craftsperson develops a style and personal approach that reflects their philosophy and experience. In programming, this translates to consistent naming conventions, commenting style, or preferred design patterns.  

How: Develop a personal coding style based on readability and best practices. This can include specific naming conventions, consistent indentation, and clarity in variable and method naming. Adhering to style guides (like PEP 8 for Python) helps ensure your code is easy to read and maintain, even by others.


### Tool Proficiency and Customization

Why: Just as a craftsperson maintains and customizes their tools, programmers benefit from mastering and tailoring their tools to enhance productivity and code quality.  

How: Invest time in learning your IDE, command-line tools, version control, and other essential tools. Customize your environment to streamline tasks, automate repetitive actions, and enhance productivity. Configuration management (e.g., .vimrc or .zshrc) and custom scripts can save time and reinforce good habits.


### Regular Retrospective and Self-Improvement

Why: Craftspersons often reflect on their work to identify ways to improve. In programming, this means periodically reviewing past projects to learn from mistakes and successes.  

How: Set aside time to review completed projects or code bases and analyze what could be improved. Look for patterns in your work where you might consistently struggle or excel, and focus on refining those areas. Document lessons learned and incorporate them into future projects.


### Mentoring and Knowledge Sharing

Why: Craftsmanship traditionally involves passing down skills and knowledge. In programming, mentoring helps build a collaborative culture and fosters collective code ownership.  

How: Engage in mentoring opportunities, whether formal or informal. Offer guidance in code reviews, lead workshops, or provide feedback to less experienced developers. This not only helps the mentee but solidifies the mentor's own understanding and promotes good coding practices.


### Philosophy of Craftsmanship in Programming

The idea of "programming as a craft” isn't just about the technical skill but also involves a mindset of care, patience, and a commitment to quality. In practice, this means:

	•	Pride in Craftsmanship: Taking pride in the code produced and feeling a sense of ownership, not only in the final product but in the details of how it was made.  
	•	Learning by Doing and Repeating: Repeated practice, hands-on experimentation, and an openness to learning from mistakes are crucial. Like any craft, mastery in programming comes through hands-on experience.  
	•	Quality Over Quantity: Craftsmanship emphasizes the importance of producing high-quality work that stands the test of time, as opposed to cranking out quick, disposable solutions.  
	•	Continuous Learning and Adaptation: Programming as a craft involves a commitment to learning and adapting. Just as a woodworker might experiment with different woods or techniques, a programmer should be open to new languages, paradigms, and methodologies.

*Conclusion*

*Programming as a craft is about developing a mastery over one's tools and code while fostering habits that ensure quality, readability, and maintainability. This perspective values skill, patience, and constant improvement, and it blends the personal with the practical, encouraging programmers to take pride in their work and treat each project as an opportunity to refine their craft.*



1. "The Pragmatic Programmer” by Andrew Hunt and David Thomas  
This book is a cornerstone for the idea of programming as a craft. Hunt and Thomas discuss "pragmatic” approaches to software development, emphasizing adaptability, craftsmanship, and continuous learning. Key topics include debugging, code quality, and tool mastery—core principles for a craft-focused mindset.  

2.	"Software Craftsmanship: The New Imperative” by Pete McBreen  
McBreen's book directly addresses the notion of software development as a craft, contrasting it with factory-like approaches in programming. He makes the case for valuing craftsmanship and provides a roadmap for how developers can cultivate skill and pride in their work. This book has been instrumental in popularizing the software craftsmanship movement.  

3.	"Apprenticeship Patterns: Guidance for the Aspiring Software Craftsman” by Dave Hoover and Adewale Oshineye  
Hoover and Oshineye focus on mentorship and learning within the programming community, framing software development as a journey of continuous improvement. Their book is organized around patterns that can help programmers find a path to mastery, making it a practical guide for those approaching software as a craft.  

4.	"Clean Code: A Handbook of Agile Software Craftsmanship” by Robert C. Martin (Uncle Bob)  
This widely acclaimed book emphasizes writing clean, readable, and maintainable code, which are all qualities valued in craftsmanship. Martin argues for a disciplined approach to coding and provides principles and best practices to improve the quality and longevity of software.  

5.	"Refactoring: Improving the Design of Existing Code” by Martin Fowler  
Refactoring is an essential practice for any programmer focused on craftsmanship. Fowler's book provides a comprehensive guide to restructuring code to improve readability, maintainability, and performance without changing its functionality. This iterative process is central to the idea of treating code as a crafted product that evolves and improves over time.  

6.	The Software Craftsmanship Manifesto (softwarecraftsmanship.org)  
The Software Craftsmanship Manifesto is a statement of principles by advocates of the craftsmanship approach. It highlights the value of honing skills, producing high-quality code, and fostering collaborative learning environments. The manifesto's website contains resources, community discussions, and related events.



1. Books

"The Pragmatic Programmer” by Andrew Hunt and David Thomas  
This classic book advocates a practical, craft-like approach to software development. It emphasizes lifelong learning, personal responsibility, and techniques for honing programming skills.  
Reference: Hunt, A., & Thomas, D. (1999). The Pragmatic Programmer: Your Journey to Mastery. Addison-Wesley Professional.

"Clean Code: A Handbook of Agile Software Craftsmanship” by Robert C. Martin  
Often considered essential reading, this book provides concrete advice on writing maintainable, readable code and is a foundational text on craftsmanship in programming.  
Reference: Martin, R. C. (2008). Clean Code: A Handbook of Agile Software Craftsmanship. Prentice Hall.

"Apprenticeship Patterns: Guidance for the Aspiring Software Craftsman” by Dave Hoover and Adewale Oshineye  
This book presents the idea of apprenticeship in software development, similar to traditional crafts. It provides strategies for developing programming skills through learning from others, practicing regularly, and seeking continual improvement.  
Reference: Hoover, D., & Oshineye, A. (2009). Apprenticeship Patterns: Guidance for the Aspiring Software Craftsman. O'Reilly Media.

"The Software Craftsman: Professionalism, Pragmatism, Pride” by Sandro Mancuso  
Mancuso advocates for a craft-driven approach to software development, focusing on quality, responsibility, and pride in one's work. He argues that good craftsmanship in software development involves dedication to professionalism and continuous improvement.  
Reference: Mancuso, S. (2014). The Software Craftsman: Professionalism, Pragmatism, Pride. Pearson.

"Coders at Work: Reflections on the Craft of Programming” by Peter Seibel  
This book is a collection of interviews with well-known programmers, discussing their perspectives on programming as a craft. It offers a diverse look at the ways different developers view coding and the approaches they take to master it.  
Reference: Seibel, P. (2009). Coders at Work: Reflections on the Craft of Programming. Apress.


2. Articles and Papers

- "Programming as Theory Building” by Peter Naur  
  Naur presents programming as an activity centered on building theory and knowledge
  rather than merely creating code. This approach aligns with the craftsmanship philosophy,
  as it stresses understanding and insight.  
  Reference: Naur, P. (1985). "Programming as Theory Building.” Microprocessing and
  Microprogramming, 15(5), 253-261.  

- "What is Software Design?” by Jack W. Reeves  
  This essay argues that programming is a form of design and that software should be
  treated as a craft. It's a widely referenced piece that has influenced the view of
  software engineering as a hands-on discipline.  
  Reference: Reeves, J. W. (1992). "What is Software Design?” C++ Journal, 2(2).  

- "The Art, Science, and Engineering of Programming” by Peter Van Roy  
  Van Roy examines the balance of creativity (art), systematic approaches (science), and
  practical constraints (engineering) in programming, which can be helpful for those interested
  in seeing programming as both a craft and a technical discipline.  
  Reference: Van Roy, P. (2017). "The Art, Science, and Engineering of Programming.” In
  Proceedings of the 2017 ACM SIGPLAN International Symposium on New Ideas, New Paradigms,
  and Reflections on Programming and Software (pp. 1-5).


3. Influential Blogs and Online Resources

- The Software Craftsmanship Movement  
- This movement advocates for craftsmanship in software development, focusing on quality, accountability, and mentorship. The Software Craftsmanship Manifesto (http://manifesto.softwarecraftsmanship.org/) is a short but influential document advocating for a craft-based approach in programming.  
- Martin Fowler's blog
- Martin Fowler, a prominent software engineer, often writes about craftsmanship, design, and agile methodologies. His blog contains many insightful articles on these topics, accessible at https://martinfowler.com/.  
- "The Humble Programmer” by Edsger Dijkstra  
- Although not specifically about craftsmanship, this classic essay by Dijkstra discusses the humility and discipline required in programming, which aligns well with the craftsmanship mindset.  
- Reference: Dijkstra, E. W. (1972). "The Humble Programmer.” Communications of the ACM, 15(10), 859-866.


4. Academic Approaches

- Computing Curricula by ACM and IEEE  

- The ACM and IEEE guidelines for computer science education, such as Computing Curricula 2020,
  also emphasize software development skills that align with craftsmanship, such as debugging,
  testing, and maintainable code.  

- Reference: ACM and IEEE Computer Society. (2020). Computing Curricula 2020.
  https://www.acm.org/binaries/content/assets/education/curricula-recommendations/cc2020.pdf


These sources provide valuable insights into programming as a hands-on, iterative discipline
that combines practical skills, quality focus, and continual improvement—qualities that align
well with the concept of programming as a craft.


-----

Treating programming as a “craft” means focusing not only on honing technical skills but also on applying deliberate, hands-on approaches to achieve high-quality results. Here are some methods and tools that align with this craft-oriented mindset in software development.

1. Deliberate Practice and Code Katas

	•	Practice with Purpose: Deliberate practice, a concept often applied in skill development, involves focusing on areas that challenge your current abilities. For programming, this can mean working on projects just outside your comfort zone or using exercises specifically designed to improve skills.
	•	Code Katas: These are small coding exercises focused on refining technique rather than building full applications. Popularized by Dave Thomas, code katas are designed to be repeatable so that a developer can focus on improving specific skills, like refactoring or using algorithms efficiently. Platforms like KataCoda or Codewars are built for this purpose.

2. Version Control Mastery (Git)

	•	Commit Discipline: Use version control systems like Git not only as a storage tool but as a way to document and shape the evolution of your code. Good commit messages and atomic, focused commits help you craft software in manageable increments.
	•	Branching Strategies: Mastering techniques like Git Flow, feature branches, and pull requests can help you build robust, maintainable codebases. It also promotes thinking about how each change affects the project holistically.

3. TDD and Automated Testing (Crafting Reliable Code)

	•	Test-Driven Development (TDD): TDD enforces writing tests before code, ensuring functionality while discouraging over-engineering. This aligns with craftsmanship because it emphasizes creating code that is immediately validated for correctness and relevance.
	•	Behavior-Driven Development (BDD): BDD is an extension of TDD with a stronger focus on the “why” behind features. Writing tests in plain language (using tools like Cucumber) aligns well with a craftsman’s goal of ensuring software truly meets user needs.
	•	Continuous Testing: Integrate tests into your development cycle so that quality checks are performed automatically with every change, using tools like Jenkins, Travis CI, or GitHub Actions.

4. Refactoring as an Ongoing Practice

	•	Code Smells and Patterns: A craftsman develops an instinct for “code smells”—signs that code needs improvement, such as large classes, duplicate code, or long methods. Tools like SonarQube or Code Climate help identify these, but cultivating an eye for these issues helps one preemptively avoid them.
	•	Refactoring Techniques: Methods from Martin Fowler’s Refactoring book, such as “Extract Method,” “Rename Variable,” and “Reduce Conditional Complexity,” allow you to incrementally improve code without altering its functionality, much like a craftsperson would refine their work over time.

5. Code Review as a Learning and Refinement Tool

	•	Peer Reviews: Engaging in regular code reviews with peers promotes knowledge sharing and encourages a culture of continuous improvement. When treated as part of the craft, code reviews are more than a check; they’re a conversation about how code can be more efficient, readable, and maintainable.
	•	Self-Reviews: Developing the habit of reviewing one’s code after a cooling-off period allows a developer to spot areas for improvement and recognize patterns in their work that could use refining.

6. Emphasis on Readability and Code Aesthetics

	•	Readable Code Matters: Just as a well-crafted object is often visually pleasing, well-written code has aesthetic qualities: clear naming, consistent formatting, and minimal complexity. Style guides, like Google’s Python Style Guide, help maintain readability and coherence across teams.
	•	Commenting Thoughtfully: Comments are often misused, but they can add significant value if crafted thoughtfully. Focus on the “why” behind decisions rather than the “what,” which should be clear from the code itself.

7. Documentation as a Living, Crafted Part of Code

	•	Maintain Living Documentation: Documentation is often neglected, but a craftsman sees it as part of the deliverable. Tools like Javadoc, Sphinx, or automated API documentation generators help ensure that documentation evolves with the code.
	•	Documentation for Usability: Well-crafted documentation is readable and usable. Consider it as part of the user experience of your software, especially in public or collaborative projects.

8. Use of Design Patterns

	•	Patterns for Consistency and Maintainability: Design patterns—like Singleton, Factory, Observer—provide standardized solutions to common problems. They help developers avoid reinventing solutions, focusing instead on crafting code that fits well within these well-tested templates.
	•	Anti-Patterns Awareness: Recognizing and avoiding anti-patterns, such as the “God Object” or “Spaghetti Code,” is a skill that aligns with craftsmanship, emphasizing clean, modular, and efficient code.

9. Enforcing Craftsmanship Through Static Analysis Tools

	•	Linters and Formatters: Tools like ESLint (JavaScript), Pylint (Python), and Prettier help enforce style rules and catch common mistakes early. They keep the codebase clean and uniform, much like a craftsperson ensures their workspace and materials are organized.
	•	Code Quality Analysis: Tools like SonarQube, Code Climate, or Coverity run deeper checks on code quality, identifying complex or error-prone areas that need improvement.

10. Continuous Integration and Continuous Deployment (CI/CD)

	•	Automated Pipelines: A CI/CD pipeline, such as those built with Jenkins, GitLab CI, or CircleCI, provides a means to automate the build, testing, and deployment process. Automating these processes ensures high standards in every build.
	•	Frequent, Smaller Deployments: Frequent releases allow developers to focus on smaller, more manageable changes, making it easier to spot and fix problems quickly—a hallmark of a skilled craftsperson who maintains control over their work.

11. Feedback Loops and Iteration

	•	User Feedback: Collecting feedback from users and stakeholders keeps your work grounded in real-world needs. Treating feedback as part of the craftsmanship process aligns with creating something functional, useful, and adaptable.
	•	Rapid Iteration Cycles: Shorter development cycles, such as sprints in Agile, allow frequent refinements and adjustments. These iterative processes parallel the hands-on, incremental adjustments that are central to craft-based disciplines.

12. Mindset of Ownership and Continuous Learning

	•	Code Ownership: A craftsman takes ownership of their code. They view their code as a reflection of their professionalism and commitment, leading them to revisit and improve it over time.
	•	Dedication to Learning: Engaging in ongoing education—reading, attending workshops, pair programming, and staying updated with industry practices—is essential. Just as a traditional craftsman may refine their skills through study and mentorship, so too must a programmer cultivate lifelong learning.

These methods align well with the craftsmanship model because they emphasize intentionality, quality, and continuous improvement. The key is to approach development as a balance of skillful execution and thoughtful problem-solving, similar to traditional craft disciplines.



-----
Large Language Models (LLMs) like GPT have vast potential to support programming as a craft by acting as intelligent companions in the coding process. By aiding with everything from coding fundamentals to advanced problem-solving, LLMs can help enhance many of the craft-based techniques we just discussed. Here’s a look at some ways LLMs might bolster the craft of programming in the future:

1. Enhanced Learning and Skill-Building Support

	•	Guided Practice and Code Katas: LLMs can dynamically generate custom exercises and code katas tailored to a developer’s skill level and goals. They could provide immediate feedback, suggest refinements, and even introduce new concepts incrementally. By understanding where a developer might be struggling, LLMs can offer targeted practice in areas like algorithms, refactoring, or debugging.
	•	On-Demand Code Reviews and Feedback: LLMs can simulate a code review partner, analyzing your code and providing feedback on style, readability, structure, and potential pitfalls. This can help beginners develop best practices faster while allowing advanced developers to refine their techniques.

2. Real-Time Pair Programming

	•	Conversational Coding Partners: Acting as a virtual “pair programmer,” an LLM can walk developers through challenging coding tasks. It could help debug, suggest optimizations, and explain code intricacies as you write. For those learning TDD, the LLM could even prompt which tests to write next and suggest how to make failing tests pass.
	•	Continuous Testing Recommendations: While writing code, LLMs can suggest test cases that cover edge cases or recommend ways to make the tests more comprehensive, promoting a more robust, test-driven development approach.

3. Improving Readability and Style Consistency

	•	Contextual Code Refactoring: LLMs could assist with refactoring by recommending improvements to naming, structure, and complexity. They can analyze code for “code smells” and suggest changes that align with clean code principles, ensuring readability and maintainability are built into every project.
	•	Customized Style Guides and Enforcement: By adapting to project-specific styles or organizational guidelines, LLMs can help ensure consistency across a codebase. This means providing style suggestions or flagging inconsistencies based on pre-set or dynamically learned rules, much like an intelligent linter.

4. Documentation and Communication

	•	Automatic, Context-Aware Documentation: LLMs can generate in-line comments, function-level explanations, and high-level documentation. They can also summarize large codebases, explain unfamiliar APIs, and even automatically document the “why” behind decisions made during development.
	•	Code Summarization and Knowledge Sharing: LLMs could generate summaries that allow developers to quickly understand a codebase. This would be especially helpful in large projects, enabling faster onboarding of new developers and making code review more efficient.

5. Streamlined Design Patterns and Anti-Patterns Detection

	•	Smart Pattern Suggestions: As you build, LLMs can suggest design patterns that fit the current structure or offer alternatives based on best practices. For example, if it detects a Singleton pattern that might lead to tight coupling, it might suggest an alternative approach.
	•	Anti-Pattern Alerts: By analyzing code in real-time, LLMs can warn about potential anti-patterns or structural issues, suggesting more maintainable and scalable alternatives. This allows developers to identify and fix problematic code before it becomes deeply ingrained in the system.

6. Enhanced Debugging and Troubleshooting

	•	Instant Debugging Assistance: LLMs could analyze error messages, stack traces, and code context to pinpoint likely causes of issues, offering recommendations on how to fix them. This would be especially useful for complex bugs that span multiple layers or modules.
	•	Interactive Bug Walkthroughs: When debugging a challenging problem, developers could walk through the code with the LLM, which could help identify overlooked issues, suggest tests to isolate problems, or provide explanations for complex interactions.

7. Version Control and Change Analysis

	•	Commit Message Suggestions: LLMs could generate meaningful commit messages based on code diffs, encouraging more descriptive, uniform, and useful commit logs. It could also automatically identify and group changes by functionality or purpose, making version history more navigable.
	•	Code Diff Summaries and Impact Analysis: When reviewing code changes, an LLM could highlight areas affected by a recent update, suggest potential tests to run, and flag any dependencies that might be impacted by the changes. This would make peer reviews more productive and ensure careful consideration of system-wide impacts.

8. Integrating Craftsmanship in Continuous Integration/Deployment (CI/CD)

	•	Automated Code Quality Checks: LLMs could analyze code in the CI/CD pipeline, identifying potential quality issues before they’re merged into the main codebase. By providing recommendations on code improvements or highlighting potential bottlenecks, LLMs can help maintain high-quality code at every stage.
	•	Automated Refactoring Suggestions Post-Deployment: LLMs could monitor code usage patterns and performance metrics, suggesting post-deployment refactoring if it detects inefficiencies. This aligns with a craftsman’s approach of iteratively refining their work.

9. Encouraging Continuous Learning and Knowledge Expansion

	•	Personalized Learning Paths: LLMs could recommend resources, courses, or advanced reading based on a developer’s skills and goals. For instance, if someone is trying to master concurrency, the LLM might recommend specific exercises or articles to deepen their understanding.
	•	Knowledge Bases for Best Practices: By integrating with documentation, code repositories, and forums, LLMs can serve as a live knowledge repository. They can provide developers with immediate, contextual answers, making it easy to learn best practices without disrupting the flow of work.

10. Supporting Ownership and Crafting Maintainable Systems

	•	Legacy Code Refactoring: LLMs can assist in refactoring and updating legacy systems by suggesting modern practices and technologies that could replace outdated methods. This aligns with craftsmanship’s emphasis on creating software that stands the test of time.
	•	Feedback Loops and Code Improvement Suggestions: By monitoring project metrics (like code complexity or bug frequency), LLMs could provide proactive feedback and suggest improvements, fostering a culture of continuous refinement.

Challenges and Considerations

Of course, there are a few challenges and ethical considerations to keep in mind:

	•	Data Security: Using LLMs, especially in sensitive or proprietary codebases, requires strict data handling and security measures.
	•	Model Bias and Code Quality: LLMs trained on vast datasets may reflect the quality of that data. Developers should critically evaluate suggestions rather than accepting them unexamined.
	•	Over-Reliance on Automation: Craftsmanship requires a deep, personal understanding of code, and too much dependence on LLMs could impede skill development. Striking a balance between automation and personal expertise will be essential.

Final Thoughts

As programming matures as a craft, LLMs can support developers by providing insights, automating tedious aspects, and encouraging best practices. Rather than replacing the developer’s intuition and skill, they act as powerful tools to augment craftsmanship, making it easier for developers to focus on design, creativity, and quality. In the future, LLMs could help create an environment where programming truly combines the best of art, science, and craftsmanship, evolving alongside the developer as they hone their craft.
