{\rtf1\ansi\ansicpg1252\cocoartf2821
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\froman\fcharset0 Times-Roman;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;}
\paperw11900\paperh16840\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\partightenfactor0

\f0\fs24 \cf0 \expnd0\expndtw0\kerning0
The interpreter manipulates entities called PostScript objects. Some objects are data, such as numbers, boolean values, strings, and arrays. Other objects are elements of programs to be executed, such as names, operators, and procedures. However, there is not a distinction between data and programs; any PostScript object may be treated as data or be executed as part of a program. The interpreter operates by executing a sequence of objects. The effect of executing a particular object depends on that object\'92s type, attributes, and value. For example, executing a number object causes the interpreter to push a copy of that object on the operand stack (to be described shortly). Executing a name object causes the interpreter to look up the name in a dictionary, fetch the associated value, and execute it. Executing an operator object causes the interpreter to perform a built-in action, such as adding two numbers or painting characters in raster memory. The objects to be executed by the interpreter come from two principal sources: \'95 A character stream may be scanned according to the syntax rules of the PostScript language, producing a sequence of new objects. As each object is scanned, it is immediately executed. The character stream may come from an external source, such as a file or a communication channel, or it may come from a string object previously stored in the PostScript interpreter\'92s memory. \'95 Objects previously stored in an array in memory may be executed in sequence. Such an array is known as a procedure.\
\
The interpreter can switch back and forth between executing a procedure and scanning a character stream. For example, if the interpreter encounters a name in a character stream, it executes that name by looking it up in a dictionary and retrieving the associated value. If that value is a procedure object, the interpreter suspends scanning the character stream and begins executing the objects in the procedure. When it reaches the end of the procedure, it resumes scanning the character stream where it left off. The interpreter maintains an execution stack for remembering all of its suspended execution contexts.\
\
\pard\pardeftab720\partightenfactor0
\cf0 \outl0\strokewidth0 \strokec2 The PostScript language differs from most other programming languages in that it does not have any syntactic entity for a \'93program,\'94 nor is it necessary for an entire \'93program\'94 to exist in one place at one time. There is no notion of \'93reading in\'94 a program before executing it. Instead, the PostScript interpreter consumes a program by reading and executing one syntactic entity at a time. From the interpreter\'92s point of view, the program has no permanent existence. Execution of the program may have side effects in the interpreter\'92s memory or elsewhere. These side effects may include the creation of procedure objects in memory that are intended to be invoked later in the program; their execution is deferred.\
\
It is not correct to think that the PostScript interpreter \'93executes\'94 the character stream directly. Rather, a scanner groups characters into tokens according to the PostScript language syntax rules. It then assembles one or more tokens to create a PostScript object\'97in other words, a data value in the interpreter\'92s memory. Finally, the interpreter executes the object. For example, when the scanner encounters a group of consecutive digits surrounded by spaces or other separators, it assembles the digits into a token and then converts the token into a number object represented internally as a binary integer. The interpreter then executes this number object; in this case, it pushes a copy of the object on the operand stack.\
\
}