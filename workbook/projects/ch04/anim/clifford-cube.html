<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Clifford algebra for a 3D cube</title>
    <style>
        canvas {
            display: block;
            margin: 0 auto;
            background: #f0f0f0;
        }
    </style>
</head>
<body>
    <canvas id="cubeCanvas" width="500" height="500"></canvas>

    <script>
        const canvas = document.getElementById('cubeCanvas');
        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;

        // cube vertices (8 vertices for a cube)
        const vertices = [
            [-1, -1, -1], [1, -1, -1], [1, 1, -1], [-1, 1, -1],  // back face
            [-1, -1, 1],  [1, -1, 1],  [1, 1, 1],  [-1, 1, 1]   // front face
        ];

        const edges = [
            [0, 1], [1, 2], [2, 3], [3, 0],  // back face edges
            [4, 5], [5, 6], [6, 7], [7, 4],  // front face edges
            [0, 4], [1, 5], [2, 6], [3, 7]   // connecting edges
        ];

        // helper function to multiply two vectors using geometric product
        function geometricProduct(a, b) {
            return [
                a[1] * b[2] - a[2] * b[1],  // x-component
                a[2] * b[0] - a[0] * b[2],  // y-component
                a[0] * b[1] - a[1] * b[0]   // z-component
            ];
        }

        // function to generate a rotor for rotating around an axis
        function rotor(angle, axis) {
            const halfAngle = angle / 2;
            const sinHalfAngle = Math.sin(halfAngle);
            return [
                Math.cos(halfAngle),        // scalar part of rotor
                axis[0] * sinHalfAngle,     // x-component
                axis[1] * sinHalfAngle,     // y-component
                axis[2] * sinHalfAngle      // z-component
            ];
        }

        // function to rotate a vertex using a rotor
        function rotate(vertex, rotor) {
            // convert vertex to a multivector (with 0 scalar part)
            const v = [0, ...vertex];

            // conjugate of rotor (reverse rotor)
            const rConjugate = [rotor[0], -rotor[1], -rotor[2], -rotor[3]];

            // apply rotor to vertex using r * v * r^*
            const rv = multiplyRotor(rotor, v);
            const result = multiplyRotor(rv, rConjugate);

            // return the rotated vector part
            return result.slice(1); // remove scalar part
        }

        // function to apply a rotor to a vector (rotation)
        function multiplyRotor(rotor, vec) {
            const scalar = rotor[0] * vec[0] - rotor[1] * vec[1] - rotor[2] * vec[2] - rotor[3] * vec[3];
            const x = rotor[0] * vec[1] + rotor[1] * vec[0] + rotor[2] * vec[3] - rotor[3] * vec[2];
            const y = rotor[0] * vec[2] - rotor[1] * vec[3] + rotor[2] * vec[0] + rotor[3] * vec[1];
            const z = rotor[0] * vec[3] + rotor[1] * vec[2] - rotor[2] * vec[1] + rotor[3] * vec[0];
            return [scalar, x, y, z];
        }

        // projection function to map 3D points to 2D
        function project([x, y, z]) {
            const scale = 200 / (z + 4); // simple perspective projection
            return [
                x * scale + width / 2,
                y * scale + height / 2
            ];
        }

        // draw the cube using rotors
        function drawCube(rotorX, rotorY) {
            ctx.clearRect(0, 0, width, height);

            // rotate all vertices by applying the two rotors
            const transformedVertices = vertices.map(vertex => {
                let rotatedVertex = rotate(vertex, rotorX);  // rotate around X
                return rotate(rotatedVertex, rotorY);        // rotate around Y
            });

            // draw all edges of the cube
            edges.forEach(([start, end]) => {
                const [x1, y1] = project(transformedVertices[start]);
                const [x2, y2] = project(transformedVertices[end]);

                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            });
        }

        let angleX = 0;
        let angleY = 0;

        // animation loop to keep rotating the cube
        function animate() {
            const rotorX = rotor(angleX, [1, 0, 0]); // rotor for X-axis
            const rotorY = rotor(angleY, [0, 1, 0]); // rotor for Y-axis

            drawCube(rotorX, rotorY);

            angleX += 0.01;
            angleY += 0.015;
            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>