#!/usr/bin/env python3

"""
Advanced PL/0 Compiler Plugins
Provides additional code generation, optimization, and analysis capabilities
"""

import os
import sys
from typing import Any, List, Dict, Optional, Set, Tuple
from abc import ABC, abstractmethod

# Import the core compiler components and plugin system
try:
    from plugins import Plugin, plugin_function
    from core import (
        ASTNode, Visitor, CompilerContext, MessageCollector, 
        BlockNode, AssignNode, CallNode, ReadNode, WriteNode,
        CompoundNode, NestedBlockNode, IfNode, WhileNode,
        OperationNode, VariableNode, NumberNode
    )
except ImportError:
    print("Error: Cannot import required modules. Make sure pl0_core.py and plugins.py are available.")
    sys.exit(1)



class CCodeGenPlugin(Plugin):
    """Plugin to generate C code from PL/0 AST"""
    
    def __init__(self):
        super().__init__(
            "c_codegen",
            "Generates C code from PL/0 AST",
            "1.0"
        )

    def get_dependencies(self) -> List[str]:
        return ["ast_optimizer"]

    def execute(self, ast: ASTNode, context: CompilerContext, messages: MessageCollector) -> str:
        generator = CCodeGenerator(context, messages)
        c_code = generator.generate(ast)
        
        # Generate output filename
        if context.base_name:
            filename = f"{context.base_name}.c"
        else:
            filename = "output.c"
        
        # Write to file
        output_path = context.get_output_path(filename)
        try:
            with open(output_path, 'w') as f:
                f.write("/* Generated by PL/0 Compiler */\n")
                f.write("#include <stdio.h>\n")
                f.write("#include <stdlib.h>\n\n")
                f.write(c_code)
            
            messages.info(f"C code generated: {filename}")
        except Exception as e:
            messages.error(f"Failed to write C code: {e}")
        
        return c_code


class CCodeGenerator(Visitor):
    """Generates C code from AST"""
    
    def __init__(self, context: CompilerContext, messages: MessageCollector):
        self.context = context
        self.messages = messages
        self.code = []
        self.indent_level = 0
        self.procedures = []

    def generate(self, ast: ASTNode) -> str:
        """Generate C code from AST"""
        self.code = []
        self.procedures = []
        try:
            ast.accept(self)
            
            # Add main function wrapper
            result_lines = []
            result_lines.extend(self.procedures)
            result_lines.append("")
            result_lines.append("int main() {")
            result_lines.extend(["    " + line for line in self.code])
            result_lines.append("    return 0;")
            result_lines.append("}")
            
            result = '\n'.join(result_lines)
            self.messages.debug("C code generation completed")
            return result
        except Exception as e:
            self.messages.error(f"C code generation failed: {str(e)}")
            raise

    def _indent(self) -> str:
        return "    " * self.indent_level

    def _emit(self, line: str):
        self.code.append(self._indent() + line)

    def visit_block(self, node: BlockNode):
        # Declare variables
        if node.variables:
            for var_name in node.variables:
                self._emit(f"int {var_name} = 0;")
            self._emit("")
        
        # Generate procedure definitions (stored separately)
        for proc_name, proc_block in node.procedures:
            proc_generator = CCodeGenerator(self.context, self.messages)
            proc_generator.indent_level = 0
            proc_block.accept(proc_generator)
            
            proc_code = []
            proc_code.append(f"void {proc_name}(void) {{")
            proc_code.extend(["    " + line for line in proc_generator.code])
            proc_code.append("}")
            proc_code.append("")
            
            self.procedures.extend(proc_code)
        
        # Generate main statement
        node.statement.accept(self)

    def visit_assign(self, node: AssignNode):
        expr_code = self._generate_expression(node.expression)
        self._emit(f"{node.var_name} = {expr_code};")

    def visit_call(self, node: CallNode):
        self._emit(f"{node.proc_name}();")

    def visit_read(self, node: ReadNode):
        self._emit(f'printf("Enter value for {node.var_name}: ");')
        self._emit(f"scanf(\"%d\", &{node.var_name});")

    def visit_write(self, node: WriteNode):
        expr_code = self._generate_expression(node.expression)
        self._emit(f'printf("%d\\n", {expr_code});')

    def visit_compound(self, node: CompoundNode):
        for stmt in node.statements:
            stmt.accept(self)

    def visit_nested_block(self, node: NestedBlockNode):
        self._emit("{")
        self.indent_level += 1
        
        # Declare nested variables
        for var_name in node.variables:
            self._emit(f"int {var_name} = 0;")
        
        # Generate statements
        for stmt in node.statements:
            stmt.accept(self)
            
        self.indent_level -= 1
        self._emit("}")

    def visit_if(self, node: IfNode):
        condition_code = self._generate_expression(node.condition)
        self._emit(f"if ({condition_code}) {{")
        self.indent_level += 1
        node.then_statement.accept(self)
        self.indent_level -= 1
        self._emit("}")

    def visit_while(self, node: WhileNode):
        condition_code = self._generate_expression(node.condition)
        self._emit(f"while ({condition_code}) {{")
        self.indent_level += 1
        node.body.accept(self)
        self.indent_level -= 1
        self._emit("}")

    def visit_operation(self, node: OperationNode):
        # This should not be called directly
        pass

    def visit_variable(self, node: VariableNode):
        # This should not be called directly
        pass

    def visit_number(self, node: NumberNode):
        # This should not be called directly
        pass

    def _generate_expression(self, node: ASTNode) -> str:
        """Generate expression code as string"""
        if isinstance(node, NumberNode):
            return str(node.value)
        elif isinstance(node, VariableNode):
            return node.name
        elif isinstance(node, OperationNode):
            left = self._generate_expression(node.left)
            right = self._generate_expression(node.right)
            if node.operator == "=":
                return f"({left} == {right})"
            else:
                return f"({left} {node.operator} {right})"
        else:
            raise ValueError(f"Unknown expression node type: {type(node)}")



class JavaScriptCodeGenPlugin(Plugin):
    """Plugin to generate JavaScript code"""
    
    def __init__(self):
        super().__init__(
            "javascript_codegen",
            "Generates JavaScript code from PL/0 AST",
            "1.0"
        )

    def get_dependencies(self) -> List[str]:
        return ["ast_optimizer"]

    def execute(self, ast: ASTNode, context: CompilerContext, messages: MessageCollector) -> str:
        generator = JavaScriptCodeGenerator(context, messages)
        js_code = generator.generate(ast)
        
        # Generate output filename
        if context.base_name:
            filename = f"{context.base_name}.js"
        else:
            filename = "output.js"
        
        # Write to file
        output_path = context.get_output_path(filename)
        try:
            with open(output_path, 'w') as f:
                f.write("// Generated by PL/0 Compiler\n")
                f.write("const readline = require('readline');\n")
                f.write("const rl = readline.createInterface({\n")
                f.write("    input: process.stdin,\n")
                f.write("    output: process.stdout\n")
                f.write("});\n\n")
                f.write("let inputBuffer = [];\n")
                f.write("let inputIndex = 0;\n\n")
                f.write("function readInt() {\n")
                f.write("    return new Promise((resolve) => {\n")
                f.write("        rl.question('Enter a number: ', (answer) => {\n")
                f.write("            resolve(parseInt(answer));\n")
                f.write("        });\n")
                f.write("    });\n")
                f.write("}\n\n")
                f.write("async function main() {\n")
                f.write(js_code)
                f.write("    rl.close();\n")
                f.write("}\n\n")
                f.write("main().catch(console.error);\n")
            
            messages.info(f"JavaScript code generated: {filename}")
        except Exception as e:
            messages.error(f"Failed to write JavaScript code: {e}")
        
        return js_code


class JavaScriptCodeGenerator(Visitor):
    """Generates JavaScript code from AST"""
    
    def __init__(self, context: CompilerContext, messages: MessageCollector):
        self.context = context
        self.messages = messages
        self.code = []
        self.indent_level = 1  # Start indented for main function

    def generate(self, ast: ASTNode) -> str:
        """Generate JavaScript code from AST"""
        self.code = []
        try:
            ast.accept(self)
            result = '\n'.join(self.code)
            self.messages.debug("JavaScript code generation completed")
            return result
        except Exception as e:
            self.messages.error(f"JavaScript code generation failed: {str(e)}")
            raise

    def _indent(self) -> str:
        return "    " * self.indent_level

    def _emit(self, line: str):
        self.code.append(self._indent() + line)

    def visit_block(self, node: BlockNode):
        # Declare variables
        if node.variables:
            vars_list = ", ".join(node.variables)
            self._emit(f"let {vars_list};")
            for var_name in node.variables:
                self._emit(f"{var_name} = 0;")
            self._emit("")
        
        # Generate procedure definitions
        for proc_name, proc_block in node.procedures:
            self._emit(f"function {proc_name}() {{")
            self.indent_level += 1
            proc_block.accept(self)
            self.indent_level -= 1
            self._emit("}")
            self._emit("")
        
        # Generate main statement
        node.statement.accept(self)

    def visit_assign(self, node: AssignNode):
        expr_code = self._generate_expression(node.expression)
        self._emit(f"{node.var_name} = {expr_code};")

    def visit_call(self, node: CallNode):
        self._emit(f"await {node.proc_name}();")

    def visit_read(self, node: ReadNode):
        self._emit(f"{node.var_name} = await readInt();")

    def visit_write(self, node: WriteNode):
        expr_code = self._generate_expression(node.expression)
        self._emit(f"console.log({expr_code});")

    def visit_compound(self, node: CompoundNode):
        for stmt in node.statements:
            stmt.accept(self)

    def visit_nested_block(self, node: NestedBlockNode):
        self._emit("{")
        self.indent_level += 1
        
        # Declare nested variables
        if node.variables:
            vars_list = ", ".join(node.variables)
            self._emit(f"let {vars_list};")
            for var_name in node.variables:
                self._emit(f"{var_name} = 0;")
        
        # Generate statements
        for stmt in node.statements:
            stmt.accept(self)
            
        self.indent_level -= 1
        self._emit("}")

    def visit_if(self, node: IfNode):
        condition_code = self._generate_expression(node.condition)
        self._emit(f"if ({condition_code}) {{")
        self.indent_level += 1
        node.then_statement.accept(self)
        self.indent_level -= 1
        self._emit("}")

    def visit_while(self, node: WhileNode):
        condition_code = self._generate_expression(node.condition)
        self._emit(f"while ({condition_code}) {{")
        self.indent_level += 1
        node.body.accept(self)
        self.indent_level -= 1
        self._emit("}")

    def visit_operation(self, node: OperationNode):
        pass

    def visit_variable(self, node: VariableNode):
        pass

    def visit_number(self, node: NumberNode):
        pass

    def _generate_expression(self, node: ASTNode) -> str:
        """Generate expression code as string"""
        if isinstance(node, NumberNode):
            return str(node.value)
        elif isinstance(node, VariableNode):
            return node.name
        elif isinstance(node, OperationNode):
            left = self._generate_expression(node.left)
            right = self._generate_expression(node.right)
            if node.operator == "=":
                return f"({left} === {right})"
            else:
                return f"({left} {node.operator} {right})"
        else:
            raise ValueError(f"Unknown expression node type: {type(node)}")






class ASTOptimizerPlugin(Plugin):
    """Plugin to optimize the AST"""
    
    def __init__(self):
        super().__init__(
            "ast_optimizer",
            "Optimizes the AST by performing constant folding and dead code elimination",
            "1.0"
        )
    
    def execute(self, ast: ASTNode, context: CompilerContext, messages: MessageCollector) -> ASTNode:
        optimizer = ASTOptimizer(messages)
        optimized_ast = optimizer.optimize(ast)
        
        stats = optimizer.get_stats()
        messages.info(f"Optimization completed: {stats['constant_folds']} constant folds, "
                     f"{stats['eliminated_nodes']} nodes eliminated")
        
        return optimized_ast
    
    def get_dependencies(self) -> List[str]:
        return []

class ASTOptimizer(Visitor):
    """Performs AST optimizations"""
    
    def __init__(self, messages: MessageCollector):
        self.messages = messages
        self.constant_folds = 0
        self.eliminated_nodes = 0
    
    def optimize(self, ast: ASTNode) -> ASTNode:
        optimized = ast.accept(self)
        return optimized if optimized is not None else ast
    
    def get_stats(self) -> Dict[str, int]:
        return {
            'constant_folds': self.constant_folds,
            'eliminated_nodes': self.eliminated_nodes
        }
    
    def visit_block(self, node: BlockNode):
        optimized_procedures = []
        for proc_name, proc_block in node.procedures:
            opt_proc = proc_block.accept(self)
            optimized_procedures.append((proc_name, opt_proc if opt_proc else proc_block))
        
        opt_statement = node.statement.accept(self)
        
        return BlockNode(
            node.variables,
            optimized_procedures,
            opt_statement if opt_statement else node.statement
        )
    
    def visit_assign(self, node: AssignNode):
        opt_expr = node.expression.accept(self)
        return AssignNode(
            node.var_name,
            opt_expr if opt_expr else node.expression
        )
    
    def visit_call(self, node: CallNode):
        return node
    
    def visit_read(self, node: ReadNode):
        return node
    
    def visit_write(self, node: WriteNode):
        opt_expr = node.expression.accept(self)
        return WriteNode(opt_expr if opt_expr else node.expression)
    
    def visit_compound(self, node: CompoundNode):
        optimized_statements = []
        for stmt in node.statements:
            opt_stmt = stmt.accept(self)
            if opt_stmt:
                optimized_statements.append(opt_stmt)
            else:
                optimized_statements.append(stmt)
        return CompoundNode(optimized_statements)
    
    def visit_nested_block(self, node: NestedBlockNode):
        optimized_statements = []
        for stmt in node.statements:
            opt_stmt = stmt.accept(self)
            if opt_stmt:
                optimized_statements.append(opt_stmt)
            else:
                optimized_statements.append(stmt)
        return NestedBlockNode(node.variables, optimized_statements)
    
    def visit_if(self, node: IfNode):
        opt_condition = node.condition.accept(self)
        opt_then = node.then_statement.accept(self)
        
        condition = opt_condition if opt_condition else node.condition
        if isinstance(condition, NumberNode):
            if condition.value != 0:
                self.eliminated_nodes += 1
                return opt_then if opt_then else node.then_statement
            else:
                self.eliminated_nodes += 1
                return None
        
        return IfNode(
            condition,
            opt_then if opt_then else node.then_statement
        )
    
    def visit_while(self, node: WhileNode):
        opt_condition = node.condition.accept(self)
        opt_body = node.body.accept(self)
        
        condition = opt_condition if opt_condition else node.condition
        if isinstance(condition, NumberNode):
            if condition.value == 0:
                self.eliminated_nodes += 1
                return None
        
        return WhileNode(
            condition,
            opt_body if opt_body else node.body
        )
    
    def visit_operation(self, node: OperationNode):
        opt_left = node.left.accept(self)
        opt_right = node.right.accept(self)
        
        left = opt_left if opt_left else node.left
        right = opt_right if opt_right else node.right
        
        if isinstance(left, NumberNode) and isinstance(right, NumberNode):
            result = self._evaluate_operation(node.operator, left.value, right.value)
            if result is not None:
                self.constant_folds += 1
                return NumberNode(result)
        
        return OperationNode(node.operator, left, right)
    
    def visit_variable(self, node: VariableNode):
        return node
    
    def visit_number(self, node: NumberNode):
        return node
    
    def _evaluate_operation(self, op: str, left: int, right: int) -> Optional[int]:
        try:
            if op == "+":
                return left + right
            elif op == "-":
                return left - right
            elif op == "*":
                return left * right
            elif op == "/":
                return left // right if right != 0 else None
            elif op == "=":
                return 1 if left == right else 0
            elif op == "<":
                return 1 if left < right else 0
            elif op == ">":
                return 1 if left > right else 0
            elif op == "<=":
                return 1 if left <= right else 0
            elif op == ">=":
                return 1 if left >= right else 0
            return None
        except Exception:
            return None

@plugin_function(
    name="ast_printer_plugin",
    description="Pretty prints the AST structure",
    dependencies=["ast_optimizer"]
)
def ast_printer(ast: ASTNode, context: CompilerContext, messages: MessageCollector) -> str:
    """Function-based plugin to pretty print AST"""
    printer = ASTPrinter(messages)
    result = printer.print(ast)
    
    if context.base_name:
        filename = f"{context.base_name}_ast.txt"
    else:
        filename = "ast.txt"
    
    output_path = context.get_output_path(filename)
    try:
        with open(output_path, 'w') as f:
            f.write(result)
        messages.info(f"AST printed to: {filename}")
    except Exception as e:
        messages.error(f"Failed to write AST output: {e}")
    
    return result

class ASTPrinter(Visitor):
    """Pretty prints the AST structure"""
    
    def __init__(self, messages: MessageCollector):
        self.messages = messages
        self.output = []
        self.indent_level = 0
    
    def print(self, ast: ASTNode) -> str:
        self.output = []
        ast.accept(self)
        return '\n'.join(self.output)
    
    def _indent(self):
        return "  " * self.indent_level
    
    def visit_block(self, node: BlockNode):
        self.output.append(f"{self._indent()}Block:")
        self.indent_level += 1
        
        if node.variables:
            self.output.append(f"{self._indent()}Variables: {', '.join(node.variables)}")
        
        if node.procedures:
            self.output.append(f"{self._indent()}Procedures:")
            for proc_name, proc_block in node.procedures:
                self.output.append(f"{self._indent()}  {proc_name}:")
                self.indent_level += 1
                proc_block.accept(self)
                self.indent_level -= 1
        
        self.output.append(f"{self._indent()}Statement:")
        self.indent_level += 1
        node.statement.accept(self)
        self.indent_level -= 1
    
    def visit_assign(self, node: AssignNode):
        expr_str = self._expression_to_string(node.expression)
        self.output.append(f"{self._indent()}Assign: {node.var_name} = {expr_str}")
    
    def visit_call(self, node: CallNode):
        self.output.append(f"{self._indent()}Call: {node.proc_name}")
    
    def visit_read(self, node: ReadNode):
        self.output.append(f"{self._indent()}Read: {node.var_name}")
    
    def visit_write(self, node: WriteNode):
        expr_str = self._expression_to_string(node.expression)
        self.output.append(f"{self._indent()}Write: {expr_str}")
    
    def visit_compound(self, node: CompoundNode):
        self.output.append(f"{self._indent()}Compound:")
        self.indent_level += 1
        for stmt in node.statements:
            stmt.accept(self)
        self.indent_level -= 1
    
    def visit_nested_block(self, node: NestedBlockNode):
        self.output.append(f"{self._indent()}Nested Block:")
        self.indent_level += 1
        
        if node.variables:
            self.output.append(f"{self._indent()}Variables: {', '.join(node.variables)}")
        
        for stmt in node.statements:
            stmt.accept(self)
        
        self.indent_level -= 1
    
    def visit_if(self, node: IfNode):
        expr_str = self._expression_to_string(node.condition)
        self.output.append(f"{self._indent()}If: {expr_str}")
        self.indent_level += 1
        node.then_statement.accept(self)
        self.indent_level -= 1
    
    def visit_while(self, node: WhileNode):
        expr_str = self._expression_to_string(node.condition)
        self.output.append(f"{self._indent()}While: {expr_str}")
        self.indent_level += 1
        node.body.accept(self)
        self.indent_level -= 1
    
    def visit_operation(self, node: OperationNode):
        pass
    
    def visit_variable(self, node: VariableNode):
        pass
    
    def visit_number(self, node: NumberNode):
        pass
    
    def _expression_to_string(self, node: ASTNode) -> str:
        if isinstance(node, NumberNode):
            return str(node.value)
        elif isinstance(node, VariableNode):
            return node.name
        elif isinstance(node, OperationNode):
            left = self._expression_to_string(node.left)
            right = self._expression_to_string(node.right)
            return f"({left} {node.operator} {right})"
        else:
            return "unknown"




class ComplexityAnalysisPlugin(Plugin):
    """Plugin for complexity analysis"""
    
    def __init__(self):
        super().__init__(
            "complexity_analysis",
            "Analyzes program complexity metrics",
            "1.0"
        )

    def get_dependencies(self) -> List[str]:
        return []

    def execute(self, ast: ASTNode, context: CompilerContext, messages: MessageCollector) -> Dict[str, Any]:
        analyzer = ComplexityAnalyzer()
        results = analyzer.analyze(ast)
        
        # Write complexity report
        if context.base_name:
            report_path = context.get_output_path(f"{context.base_name}_complexity.txt")
            self._write_complexity_report(results, report_path, messages)
        
        messages.info(f"Complexity analysis: cyclomatic={results['cyclomatic_complexity']}, "
                     f"nesting_depth={results['max_nesting_depth']}")
        return results
    
    def _write_complexity_report(self, results: Dict[str, Any], filepath: str, messages: MessageCollector):
        try:
            with open(filepath, 'w') as f:
                f.write("Complexity Analysis Report\n")
                f.write("=" * 25 + "\n\n")
                
                f.write(f"Cyclomatic Complexity: {results['cyclomatic_complexity']}\n")
                f.write(f"Maximum Nesting Depth: {results['max_nesting_depth']}\n")
                f.write(f"Total Statements: {results['total_statements']}\n")
                f.write(f"Decision Points: {results['decision_points']}\n")
                f.write(f"Loop Count: {results['loop_count']}\n")
                f.write(f"Procedure Count: {results['procedure_count']}\n")
                
                f.write(f"\nComplexity Rating: ")
                if results['cyclomatic_complexity'] <= 10:
                    f.write("Low (Simple)\n")
                elif results['cyclomatic_complexity'] <= 20:
                    f.write("Medium (Moderate)\n")
                else:
                    f.write("High (Complex)\n")
            
            messages.info(f"Complexity report saved: {os.path.basename(filepath)}")
        except Exception as e:
            messages.error(f"Failed to write complexity report: {e}")


class ComplexityAnalyzer(Visitor):
    """Analyzes program complexity"""
    
    def __init__(self):
        self.cyclomatic_complexity = 1  # Start with 1
        self.current_nesting_depth = 0
        self.max_nesting_depth = 0
        self.total_statements = 0
        self.decision_points = 0
        self.loop_count = 0
        self.procedure_count = 0
    
    def analyze(self, ast: ASTNode) -> Dict[str, Any]:
        ast.accept(self)
        return {
            'cyclomatic_complexity': self.cyclomatic_complexity,
            'max_nesting_depth': self.max_nesting_depth,
            'total_statements': self.total_statements,
            'decision_points': self.decision_points,
            'loop_count': self.loop_count,
            'procedure_count': self.procedure_count
        }
    
    def _enter_nesting(self):
        self.current_nesting_depth += 1
        self.max_nesting_depth = max(self.max_nesting_depth, self.current_nesting_depth)
    
    def _exit_nesting(self):
        self.current_nesting_depth -= 1
    
    def visit_block(self, node: BlockNode):
        self.procedure_count += len(node.procedures)
        
        # Analyze procedures
        for proc_name, proc_block in node.procedures:
            proc_block.accept(self)
        
        # Analyze main statement
        node.statement.accept(self)
    
    def visit_assign(self, node: AssignNode):
        self.total_statements += 1
        node.expression.accept(self)
    
    def visit_call(self, node: CallNode):
        self.total_statements += 1
    
    def visit_read(self, node: ReadNode):
        self.total_statements += 1
    
    def visit_write(self, node: WriteNode):
        self.total_statements += 1
        node.expression.accept(self)
    
    def visit_compound(self, node: CompoundNode):
        for stmt in node.statements:
            stmt.accept(self)
    
    def visit_nested_block(self, node: NestedBlockNode):
        self._enter_nesting()
        for stmt in node.statements:
            stmt.accept(self)
        self._exit_nesting()
    
    def visit_if(self, node: IfNode):
        self.total_statements += 1
        self.decision_points += 1
        self.cyclomatic_complexity += 1
        
        self._enter_nesting()
        node.condition.accept(self)
        node.then_statement.accept(self)
        self._exit_nesting()
    
    def visit_while(self, node: WhileNode):
        self.total_statements += 1
        self.decision_points += 1
        self.loop_count += 1
        self.cyclomatic_complexity += 1
        
        self._enter_nesting()
        node.condition.accept(self)
        node.body.accept(self)
        self._exit_nesting()
    
    def visit_operation(self, node: OperationNode):
        node.left.accept(self)
        node.right.accept(self)
    
    def visit_variable(self, node: VariableNode):
        pass
    
    def visit_number(self, node: NumberNode):
        pass

#@plugin_function("ast_printer", "Pretty prints the AST structure")
@plugin_function(
    name="ast_printer_plugin",
    description="Pretty prints the AST structure",
    dependencies=["ast_optimizer"]
)
def ast_printer_plugin(ast: ASTNode, context: CompilerContext, messages: MessageCollector) -> str:
    """Function-based plugin to print AST structure"""
    printer = ASTPrinter()
    tree_str = printer.print_ast(ast)
    
    # Write to file
    if context.base_name:
        filename = f"{context.base_name}_ast.txt"
        output_path = context.get_output_path(filename)
        try:
            with open(output_path, 'w') as f:
                f.write("Abstract Syntax Tree\n")
                f.write("=" * 20 + "\n\n")
                f.write(tree_str)
            messages.info(f"AST structure saved: {filename}")
        except Exception as e:
            messages.error(f"Failed to write AST file: {e}")
    
    return tree_str


class ASTPrinter(Visitor):
    """Pretty prints AST structure"""
    
    def __init__(self):
        self.output = []
        self.indent_level = 0
    
    def print_ast(self, ast: ASTNode) -> str:
        self.output = []
        self.indent_level = 0
        ast.accept(self)
        return '\n'.join(self.output)
    
    def _emit(self, text: str):
        indent = "  " * self.indent_level
        self.output.append(f"{indent}{text}")
    
    def visit_block(self, node: BlockNode):
        self._emit("BlockNode")
        self.indent_level += 1
        
        if node.variables:
            self._emit(f"Variables: {', '.join(node.variables)}")
        
        if node.procedures:
            self._emit("Procedures:")
            self.indent_level += 1
            for proc_name, proc_block in node.procedures:
                self._emit(f"Procedure: {proc_name}")
                self.indent_level += 1
                proc_block.accept(self)
                self.indent_level -= 1
            self.indent_level -= 1
        
        self._emit("Statement:")
        self.indent_level += 1
        node.statement.accept(self)
        self.indent_level -= 1
        
        self.indent_level -= 1
    
    def visit_assign(self, node: AssignNode):
        self._emit(f"AssignNode: {node.var_name} :=")
        self.indent_level += 1
        node.expression.accept(self)
        self.indent_level -= 1
    
    def visit_call(self, node: CallNode):
        self._emit(f"CallNode: {node.proc_name}")
    
    def visit_read(self, node: ReadNode):
        self._emit(f"ReadNode: {node.var_name}")
    
    def visit_write(self, node: WriteNode):
        self._emit("WriteNode:")
        self.indent_level += 1
        node.expression.accept(self)
        self.indent_level -= 1
    
    def visit_compound(self, node: CompoundNode):
        self._emit("CompoundNode:")
        self.indent_level += 1
        for i, stmt in enumerate(node.statements):
            self._emit(f"Statement {i + 1}:")
            self.indent_level += 1
            stmt.accept(self)
            self.indent_level -= 1
        self.indent_level -= 1
    
    def visit_nested_block(self, node: NestedBlockNode):
        self._emit("NestedBlockNode:")
        self.indent_level += 1
        if node.variables:
            self._emit(f"Variables: {', '.join(node.variables)}")
        for i, stmt in enumerate(node.statements):
            self._emit(f"Statement {i + 1}:")
            self.indent_level += 1
            stmt.accept(self)
            self.indent_level -= 1
        self.indent_level -= 1
    
    def visit_if(self, node: IfNode):
        self._emit("IfNode:")
        self.indent_level += 1
        self._emit("Condition:")
        self.indent_level += 1
        node.condition.accept(self)
        self.indent_level -= 1
        self._emit("Then:")
        self.indent_level += 1
        node.then_statement.accept(self)
        self.indent_level -= 1
        self.indent_level -= 1
    
    def visit_while(self, node: WhileNode):
        self._emit("WhileNode:")
        self.indent_level += 1
        self._emit("Condition:")
        self.indent_level += 1
        node.condition.accept(self)
        self.indent_level -= 1
        self._emit("Body:")
        self.indent_level += 1
        node.body.accept(self)
        self.indent_level -= 1
        self.indent_level -= 1
    
    def visit_operation(self, node: OperationNode):
        self._emit(f"OperationNode: {node.operator}")
        self.indent_level += 1
        self._emit("Left:")
        self.indent_level += 1
        node.left.accept(self)
        self.indent_level -= 1
        self._emit("Right:")
        self.indent_level += 1
        node.right.accept(self)
        self.indent_level -= 1
        self.indent_level -= 1
    
    def visit_variable(self, node: VariableNode):
        self._emit(f"VariableNode: {node.name}")
    
    def visit_number(self, node: NumberNode):
        self._emit(f"NumberNode: {node.value}")


#@plugin_function("bytecode_gen", "Generates simple bytecode instructions")
@plugin_function(
    name="bytecode_generator_plugin",
    description="Generates bytecode from PL/0 AST",
    dependencies=["ast_optimizer"]
)
def bytecode_generator_plugin(ast: ASTNode, context: CompilerContext, messages: MessageCollector) -> List[str]:
    """Function-based plugin to generate bytecode"""
    generator = BytecodeGenerator()
    instructions = generator.generate(ast)
    
    # Write to file
    if context.base_name:
        filename = f"{context.base_name}.bc"
        output_path = context.get_output_path(filename)
        try:
            with open(output_path, 'w') as f:
                f.write("# Generated Bytecode\n")
                for i, instr in enumerate(instructions):
                    f.write(f"{i:04d}: {instr}\n")
            messages.info(f"Bytecode generated: {filename}")
        except Exception as e:
            messages.error(f"Failed to write bytecode: {e}")
    
    return instructions


class BytecodeGenerator(Visitor):
    """Generates simple bytecode instructions"""
    
    def __init__(self):
        self.instructions = []
        self.variables = {}
        self.procedures = {}
        self.var_counter = 0
        self.label_counter = 0
        self.temp_counter = 0
    
    def generate(self, ast: ASTNode) -> List[str]:
        self.instructions = []
        ast.accept(self)
        self.instructions.append("HALT")
        return self.instructions
    
    def _emit(self, instruction: str):
        self.instructions.append(instruction)
    
    def _get_temp(self) -> str:
        temp = f"t{self.temp_counter}"
        self.temp_counter += 1
        return temp
    
    def _get_label(self) -> str:
        label = f"L{self.label_counter}"
        self.label_counter += 1
        return label
    
    def visit_block(self, node: BlockNode):
        # Declare variables
        for var in node.variables:
            self.variables[var] = self.var_counter
            self._emit(f"DECLARE {var}")
            self.var_counter += 1
        
        # Generate procedures
        for proc_name, proc_block in node.procedures:
            proc_label = f"PROC_{proc_name}"
            self.procedures[proc_name] = proc_label
            self._emit(f"{proc_label}:")
            proc_block.accept(self)
            self._emit("RETURN")
        
        # Generate main code
        node.statement.accept(self)
    
    def visit_assign(self, node: AssignNode):
        result = self._generate_expression(node.expression)
        self._emit(f"STORE {node.var_name} {result}")
    
    def visit_call(self, node: CallNode):
        if node.proc_name in self.procedures:
            self._emit(f"CALL {self.procedures[node.proc_name]}")
        else:
            self._emit(f"CALL PROC_{node.proc_name}")
    
    def visit_read(self, node: ReadNode):
        self._emit(f"READ {node.var_name}")
    
    def visit_write(self, node: WriteNode):
        result = self._generate_expression(node.expression)
        self._emit(f"WRITE {result}")
    
    def visit_compound(self, node: CompoundNode):
        for stmt in node.statements:
            stmt.accept(self)
    
    def visit_nested_block(self, node: NestedBlockNode):
        # Declare nested variables
        for var in node.variables:
            self.variables[var] = self.var_counter
            self._emit(f"DECLARE {var}")
            self.var_counter += 1
        
        for stmt in node.statements:
            stmt.accept(self)
    
    def visit_if(self, node: IfNode):
        condition_result = self._generate_expression(node.condition)
        end_label = self._get_label()
        self._emit(f"JZ {condition_result} {end_label}")
        node.then_statement.accept(self)
        self._emit(f"{end_label}:")
    
    def visit_while(self, node: WhileNode):
        start_label = self._get_label()
        end_label = self._get_label()
        self._emit(f"{start_label}:")
        condition_result = self._generate_expression(node.condition)
        self._emit(f"JZ {condition_result} {end_label}")
        node.body.accept(self)
        self._emit(f"JMP {start_label}")
        self._emit(f"{end_label}:")
    
    def visit_operation(self, node: OperationNode):
        # This is handled by _generate_expression
        pass
    
    def visit_variable(self, node: VariableNode):
        # This is handled by _generate_expression
        pass
    
    def visit_number(self, node: NumberNode):
        # This is handled by _generate_expression
        pass
    
    def _generate_expression(self, node: ASTNode) -> str:
        """Generate expression and return the result location"""
        if isinstance(node, NumberNode):
            temp = self._get_temp()
            self._emit(f"LOAD_CONST {temp} {node.value}")
            return temp
        elif isinstance(node, VariableNode):
            temp = self._get_temp()
            self._emit(f"LOAD {temp} {node.name}")
            return temp
        elif isinstance(node, OperationNode):
            left = self._generate_expression(node.left)
            right = self._generate_expression(node.right)
            result = self._get_temp()
            
            if node.operator == "+":
                self._emit(f"ADD {result} {left} {right}")
            elif node.operator == "-":
                self._emit(f"SUB {result} {left} {right}")
            elif node.operator == "*":
                self._emit(f"MUL {result} {left} {right}")
            elif node.operator == "/":
                self._emit(f"DIV {result} {left} {right}")
            elif node.operator == "=":
                self._emit(f"EQ {result} {left} {right}")
            elif node.operator == "<":
                self._emit(f"LT {result} {left} {right}")
            elif node.operator == ">":
                self._emit(f"GT {result} {left} {right}")
            elif node.operator == "<=":
                self._emit(f"LE {result} {left} {right}")
            elif node.operator == ">=":
                self._emit(f"GE {result} {left} {right}")
            
            return result
        else:
            raise ValueError(f"Unknown expression node type: {type(node)}")



class DependencyAnalysisPlugin(Plugin):
    """Plugin for dependency analysis"""
    
    def __init__(self):
        super().__init__(
            "dependency_analysis",
            "Analyzes variable and procedure dependencies",
            "1.0"
        )

    def get_dependencies(self) -> List[str]:
        return []

    def execute(self, ast: ASTNode, context: CompilerContext, messages: MessageCollector) -> Dict[str, Any]:
        analyzer = DependencyAnalyzer()
        results = analyzer.analyze(ast)
        
        # Write dependency report
        if context.base_name:
            report_path = context.get_output_path(f"{context.base_name}_dependencies.txt")
            self._write_dependency_report(results, report_path, messages)
        
        messages.info(f"Dependency analysis completed")
        return results
    
    def _write_dependency_report(self, results: Dict[str, Any], filepath: str, messages: MessageCollector):
        try:
            with open(filepath, 'w') as f:
                f.write("Dependency Analysis Report\n")
                f.write("=" * 25 + "\n\n")
                
                f.write("Variable Dependencies:\n")
                for var, deps in results['variable_dependencies'].items():
                    if deps:
                        f.write(f"  {var} depends on: {', '.join(deps)}\n")
                    else:
                        f.write(f"  {var} has no dependencies\n")
                
                f.write(f"\nProcedure Dependencies:\n")
                for proc, deps in results['procedure_dependencies'].items():
                    if deps:
                        f.write(f"  {proc} calls: {', '.join(deps)}\n")
                    else:
                        f.write(f"  {proc} calls no procedures\n")
                
                f.write(f"\nData Flow:\n")
                for stmt_type, flows in results['data_flow'].items():
                    f.write(f"  {stmt_type}:\n")
                    for flow in flows:
                        f.write(f"    {flow}\n")
            
            messages.info(f"Dependency report saved: {os.path.basename(filepath)}")
        except Exception as e:
            messages.error(f"Failed to write dependency report: {e}")


class DependencyAnalyzer(Visitor):
    """Analyzes dependencies between variables and procedures"""
    
    def __init__(self):
        self.variable_dependencies = {}
        self.procedure_dependencies = {}
        self.data_flow = {'reads': [], 'writes': [], 'assignments': []}
        self.current_procedure = None
    
    def analyze(self, ast: ASTNode) -> Dict[str, Any]:
        ast.accept(self)
        return {
            'variable_dependencies': self.variable_dependencies,
            'procedure_dependencies': self.procedure_dependencies,
            'data_flow': self.data_flow
        }
    
    def visit_block(self, node: BlockNode):
        # Initialize variable dependencies
        for var in node.variables:
            self.variable_dependencies[var] = set()
        
        # Initialize procedure dependencies
        for proc_name, _ in node.procedures:
            self.procedure_dependencies[proc_name] = set()
        
        # Analyze procedures
        for proc_name, proc_block in node.procedures:
            old_proc = self.current_procedure
            self.current_procedure = proc_name
            proc_block.accept(self)
            self.current_procedure = old_proc
        
        # Analyze main statement
        node.statement.accept(self)
    
    def visit_assign(self, node: AssignNode):
        # Find variables used in expression
        used_vars = self._get_variables_in_expression(node.expression)
        
        # Record dependency
        if node.var_name not in self.variable_dependencies:
            self.variable_dependencies[node.var_name] = set()
        self.variable_dependencies[node.var_name].update(used_vars)
        
        # Record data flow
        flow_info = f"{node.var_name} := expression using {used_vars if used_vars else 'constants'}"
        self.data_flow['assignments'].append(flow_info)
        
        node.expression.accept(self)
    
    def visit_call(self, node: CallNode):
        # Record procedure dependency
        if self.current_procedure and self.current_procedure in self.procedure_dependencies:
            self.procedure_dependencies[self.current_procedure].add(node.proc_name)
    
    def visit_read(self, node: ReadNode):
        self.data_flow['reads'].append(f"Read into {node.var_name}")
    
    def visit_write(self, node: WriteNode):
        used_vars = self._get_variables_in_expression(node.expression)
        flow_info = f"Write expression using {used_vars if used_vars else 'constants'}"
        self.data_flow['writes'].append(flow_info)
        node.expression.accept(self)
    
    def visit_compound(self, node: CompoundNode):
        for stmt in node.statements:
            stmt.accept(self)
    
    def visit_nested_block(self, node: NestedBlockNode):
        # Initialize nested variable dependencies
        for var in node.variables:
            self.variable_dependencies[var] = set()
        
        for stmt in node.statements:
            stmt.accept(self)
    
    def visit_if(self, node: IfNode):
        node.condition.accept(self)
        node.then_statement.accept(self)
    
    def visit_while(self, node: WhileNode):
        node.condition.accept(self)
        node.body.accept(self)
    
    def visit_operation(self, node: OperationNode):
        node.left.accept(self)
        node.right.accept(self)
    
    def visit_variable(self, node: VariableNode):
        pass
    
    def visit_number(self, node: NumberNode):
        pass
    
    def _get_variables_in_expression(self, node: ASTNode) -> Set[str]:
        """Extract all variables used in an expression"""
        variables = set()
        
        if isinstance(node, VariableNode):
            variables.add(node.name)
        elif isinstance(node, OperationNode):
            variables.update(self._get_variables_in_expression(node.left))
            variables.update(self._get_variables_in_expression(node.right))
        # NumberNode contributes no variables
        
        return variables

    
class PerformanceProfilerPlugin(Plugin):
    """Plugin for performance profiling estimation"""
    
    def __init__(self):
        super().__init__(
            "performance_profiler",
            "Estimates performance characteristics of PL/0 programs",
            "1.0"
        )

    def get_dependencies(self) -> List[str]:
        return []

    def execute(self, ast: ASTNode, context: CompilerContext, messages: MessageCollector) -> Dict[str, Any]:
        profiler = PerformanceProfiler()
        results = profiler.profile(ast)
        
        # Write performance report
        if context.base_name:
            report_path = context.get_output_path(f"{context.base_name}_performance.txt")
            self._write_performance_report(results, report_path, messages)
        
        messages.info(f"Performance analysis: estimated {results['total_operations']} operations, "
                     f"memory usage: {results['memory_usage']} variables")
        return results
    
    def _write_performance_report(self, results: Dict[str, Any], filepath: str, messages: MessageCollector):
        try:
            with open(filepath, 'w') as f:
                f.write("Performance Analysis Report\n")
                f.write("=" * 26 + "\n\n")
                
                f.write(f"Estimated Total Operations: {results['total_operations']}\n")
                f.write(f"Memory Usage (variables): {results['memory_usage']}\n")
                f.write(f"Stack Depth: {results['max_stack_depth']}\n")
                f.write(f"I/O Operations: {results['io_operations']}\n")
                
                f.write(f"\nOperation Breakdown:\n")
                for op_type, count in results['operation_breakdown'].items():
                    f.write(f"  {op_type}: {count}\n")
                
                f.write(f"\nHotspots (potential performance issues):\n")
                for hotspot in results['hotspots']:
                    f.write(f"  - {hotspot}\n")
                
                f.write(f"\nOptimization Suggestions:\n")
                for suggestion in results['suggestions']:
                    f.write(f"  - {suggestion}\n")
            
            messages.info(f"Performance report saved: {os.path.basename(filepath)}")
        except Exception as e:
            messages.error(f"Failed to write performance report: {e}")


class PerformanceProfiler(Visitor):
    """Estimates performance characteristics"""
    
    def __init__(self):
        self.total_operations = 0
        self.memory_usage = 0
        self.current_stack_depth = 0
        self.max_stack_depth = 0
        self.io_operations = 0
        self.operation_breakdown = {
            'arithmetic': 0,
            'assignments': 0,
            'comparisons': 0,
            'procedure_calls': 0,
            'loops': 0,
            'conditionals': 0
        }
        self.hotspots = []
        self.suggestions = []
        self.loop_nesting = 0
    
    def profile(self, ast: ASTNode) -> Dict[str, Any]:
        ast.accept(self)
        
        # Generate suggestions
        self._generate_suggestions()
        
        return {
            'total_operations': self.total_operations,
            'memory_usage': self.memory_usage,
            'max_stack_depth': self.max_stack_depth,
            'io_operations': self.io_operations,
            'operation_breakdown': self.operation_breakdown,
            'hotspots': self.hotspots,
            'suggestions': self.suggestions
        }
    
    def _generate_suggestions(self):
        """Generate optimization suggestions based on analysis"""
        if self.io_operations > 10:
            self.suggestions.append("Consider batching I/O operations for better performance")
        
        if self.max_stack_depth > 5:
            self.suggestions.append("Deep nesting detected - consider refactoring for better readability")
        
        if self.operation_breakdown['loops'] > 3:
            self.suggestions.append("Multiple loops detected - consider algorithm optimization")
        
        if self.memory_usage > 20:
            self.suggestions.append("High memory usage - consider variable reuse")
    
    def visit_block(self, node: BlockNode):
        # Count memory usage
        self.memory_usage += len(node.variables)
        
        # Analyze procedures
        for proc_name, proc_block in node.procedures:
            self.current_stack_depth += 1
            self.max_stack_depth = max(self.max_stack_depth, self.current_stack_depth)
            proc_block.accept(self)
            self.current_stack_depth -= 1
        
        # Analyze main statement
        node.statement.accept(self)
    
    def visit_assign(self, node: AssignNode):
        self.total_operations += 1
        self.operation_breakdown['assignments'] += 1
        
        # Count operations in expression
        self._count_expression_operations(node.expression)
        node.expression.accept(self)
    
    def visit_call(self, node: CallNode):
        self.total_operations += 1
        self.operation_breakdown['procedure_calls'] += 1
    
    def visit_read(self, node: ReadNode):
        self.total_operations += 1
        self.io_operations += 1
    
    def visit_write(self, node: WriteNode):
        self.total_operations += 1
        self.io_operations += 1
        self._count_expression_operations(node.expression)
        node.expression.accept(self)
    
    def visit_compound(self, node: CompoundNode):
        for stmt in node.statements:
            stmt.accept(self)
    
    def visit_nested_block(self, node: NestedBlockNode):
        self.memory_usage += len(node.variables)
        self.current_stack_depth += 1
        self.max_stack_depth = max(self.max_stack_depth, self.current_stack_depth)
        
        for stmt in node.statements:
            stmt.accept(self)
            
        self.current_stack_depth -= 1
    
    def visit_if(self, node: IfNode):
        self.total_operations += 1
        self.operation_breakdown['conditionals'] += 1
        
        self._count_expression_operations(node.condition)
        node.condition.accept(self)
        node.then_statement.accept(self)
    
    def visit_while(self, node: WhileNode):
        self.total_operations += 1
        self.operation_breakdown['loops'] += 1
        self.loop_nesting += 1
        
        if self.loop_nesting > 2:
            self.hotspots.append(f"Deeply nested loop detected (depth {self.loop_nesting})")
        
        # Estimate loop iterations (conservative estimate: 10 iterations)
        loop_multiplier = 10
        old_ops = self.total_operations
        
        self._count_expression_operations(node.condition)
        node.condition.accept(self)
        node.body.accept(self)
        
        # Multiply loop body operations
        loop_body_ops = self.total_operations - old_ops - 1
        self.total_operations += loop_body_ops * (loop_multiplier - 1)
        
        self.loop_nesting -= 1
    
    def visit_operation(self, node: OperationNode):
        node.left.accept(self)
        node.right.accept(self)
    
    def visit_variable(self, node: VariableNode):
        pass
    
    def visit_number(self, node: NumberNode):
        pass
    
    def _count_expression_operations(self, node: ASTNode):
        """Count operations in an expression"""
        if isinstance(node, OperationNode):
            self.total_operations += 1
            if node.operator in ['+', '-', '*', '/']:
                self.operation_breakdown['arithmetic'] += 1
            else:
                self.operation_breakdown['comparisons'] += 1
            
            self._count_expression_operations(node.left)
            self._count_expression_operations(node.right)


# Example usage and testing
if __name__ == "__main__":
    print("Advanced PL/0 Compiler Plugins")
    print("Available plugins:")
    print("1. CCodeGenPlugin - Generates C code")
    print("2. JavaScriptCodeGenPlugin - Generates JavaScript code") 
    print("3. ASTOptimizerPlugin - Optimizes the AST")
    print("4. ComplexityAnalysisPlugin - Analyzes program complexity")
    print("5. ast_printer_plugin - Pretty prints AST structure")
    print("6. bytecode_generator_plugin - Generates bytecode")
    print("7. DependencyAnalysisPlugin - Analyzes dependencies")
    print("8. PerformanceProfilerPlugin - Estimates performance")
    print("\nTo use these plugins, load this file with your PL/0 compiler:")
    print("python3 plugins.py --plugin advanced_plugins.py input.pl0")
