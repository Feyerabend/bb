
## A Modern Software Development Process in the Age of LLMs


__1. Client-Centered Exploration First: Communication Before Code__

Instead of rushing into requirements documents or rigid specs, the developer starts
with iterative, conversational prototyping. This is not only with the client but also
with an LLM acting as a co-thinker or idea amplifier.

Questions like:
- What problem are we solving?
- What does the domain look like?
- What does success look like for you (the client)?

LLMs excel here--rapidly rephrasing ideas, generating domain vocabularies, mockups,
and usage scenarios. Prototypes here are conceptual: sketches, dialog flows, or pseudo-UIs,
but not yet functional systems.


__2. Start with the Familiar: Build Confidence__

Rather than tackling novel or risky technical challenges up front, you focus first on:
- Functions and concepts both you and the client already understand.
- Features and workflows that are directly relatable to current practice.
- Simple datasets, reports, views, or UI flows.

This grounds the project and reduces cognitive load for both sides.
LLMs help by automating small demos, generating dummy data, and producing quick prototypes.


__3. Data-Centric Exploration: Understand the Landscape__

Shift focus from "how should the software work?" to "what data exists and what is its shape?".
This is critical and often skipped too early in conventional dev.
- Inventory: What data is available (tables, APIs, logs, etc.)?
- Granularity: What resolution, quality, completeness does it have?
- Governance: Who owns it? Privacy constraints? Access rules?

LLMs assist with data profiling, schema summarisation, sample generation, and even initial
questions about the data that developers or clients forget to ask.
This step directly feeds into more meaningful prototypes later.


__4. Progressive Complexity: Defer Hard Problems Logically__

Instead of the usual waterfall or even agile "minimum viable product", this process deliberately:
- Defers deep technical challenges (scalability, exotic algorithms, edge cases).
- Solves them only when there's clear context and understanding from the earlier data
  and prototype phases.
- Uses LLMs to simulate or stub difficult components (e.g., "simulate an API that does X"
  before you build the real integration).


__5. Co-Development and Co-Exploration: LLM as Constant Companion__

Throughout, LLMs don't replace developers but augment:
- Code generation for mundane scaffolding.
- Documentation synthesis from meetings and chats.
- Interactive simulation of workflows (via prompts).
- Suggesting overlooked edge cases or user stories.


__6. Continuous Alignment: Frequent Client Syncs__

The emphasis stays on frequent re-validation with the client--not formal sign-offs but
lightweight demos, data explorations, or what-if scenarios.
LLMs can help by auto-generating reports, comparisons, or summaries of current project
state for client consumption.


*Why this might be a Good Path*
- It de-risks projects by anchoring on what's known first (for both).
- It builds trust with clients through constant clarity and progress.
- It leverages LLMs for their strengths (summarisation, prototyping, scaffolding)
  without over-relying on them for deep domain expertise.
- It matches how humans naturally reason: moving from concrete/familiar to abstract/novel,
  not the reverse.


