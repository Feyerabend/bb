<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Gap Buffer Editor</title>
    <style>
        body { font-family: monospace; padding: 1em; }
        #editor {
            white-space: pre-wrap;
            border: 2px solid #ccc;
            padding: 10px;
            width: 600px;
            height: 200px;
            overflow-y: auto;
            outline: none;
            word-wrap: break-word;
            background-color: white;
            cursor: text;
            position: relative;
        }
        #editor:focus {
            border-color: #007acc;
            background-color: #fafafa;
        }
        #info {
            margin-top: 1em;
        }
        .cursor {
            background-color: black;
            animation: blink 1s infinite;
        }
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }
        
        /* Buffer visualization styles */
        #bufferViz {
            margin-top: 1em;
            border: 1px solid #ddd;
            padding: 10px;
            background-color: #f9f9f9;
        }
        
        .buffer-container {
            display: flex;
            flex-wrap: wrap;
            gap: 2px;
            margin: 10px 0;
            font-size: 12px;
        }
        
        .buffer-cell {
            width: 20px;
            height: 20px;
            border: 1px solid #ccc;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: monospace;
            font-size: 10px;
        }
        
        .buffer-cell.text {
            background-color: #e3f2fd;
            border-color: #1976d2;
        }
        
        .buffer-cell.gap {
            background-color: #ffebee;
            border-color: #d32f2f;
            color: #666;
        }
        
        .buffer-cell.cursor {
            background-color: #4caf50;
            border-color: #2e7d32;
            color: white;
            font-weight: bold;
        }
        
        .buffer-legend {
            display: flex;
            gap: 15px;
            margin: 10px 0;
            font-size: 12px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .legend-box {
            width: 15px;
            height: 15px;
            border: 1px solid;
        }
        
        .stats {
            margin-top: 10px;
            font-size: 12px;
            line-height: 1.4;
        }
    </style>
</head>
<body>
<h2>Gap Buffer Editor</h2>
<p><strong>Click in the editor box below and start typing!</strong></p>
<div id="editor" contenteditable="false" tabindex="0"></div>
<div id="info"></div>

<div id="bufferViz">
    <h3>Gap Buffer:</h3>
    <div class="buffer-legend">
        <div class="legend-item">
            <div class="legend-box" style="background-color: #e3f2fd; border-color: #1976d2;"></div>
            <span>Text</span>
        </div>
        <div class="legend-item">
            <div class="legend-box" style="background-color: #ffebee; border-color: #d32f2f;"></div>
            <span>Gap (unused)</span>
        </div>
        <div class="legend-item">
            <div class="legend-box" style="background-color: #4caf50; border-color: #2e7d32;"></div>
            <span>Cursor position</span>
        </div>
    </div>
    <div id="bufferDisplay" class="buffer-container"></div>
    <div id="bufferStats" class="stats"></div>
</div>

<script>
class GapBuffer {
    constructor(size = 32) {
        this.buffer = new Array(size).fill('');
        this.gapStart = 0;
        this.gapEnd = size;
        this.preferredColumn = 0;
    }
    
    get length() {
        return this.buffer.length - (this.gapEnd - this.gapStart);
    }
    
    moveCursorLeft() {
        if (this.gapStart > 0) {
            this.gapEnd--;
            this.buffer[this.gapEnd] = this.buffer[--this.gapStart];
            this.updatePreferredColumn();
        }
    }
    
    moveCursorRight() {
        if (this.gapEnd < this.buffer.length) {
            this.buffer[this.gapStart++] = this.buffer[this.gapEnd];
            this.gapEnd++;
            this.updatePreferredColumn();
        }
    }
    
    updatePreferredColumn() {
        const position = this.getCurrentPosition();
        this.preferredColumn = position.column;
    }
    
    getCurrentPosition() {
        const text = this.getText();
        let line = 0;
        let column = 0;
        
        for (let i = 0; i < this.gapStart; i++) {
            if (text[i] === '\n') {
                line++;
                column = 0;
            } else {
                column++;
            }
        }
        
        return { line, column };
    }
    
    getLineStartPosition(lineNum) {
        const text = this.getText();
        let currentLine = 0;
        let position = 0;
        
        if (lineNum === 0) return 0;
        
        for (let i = 0; i < text.length; i++) {
            if (text[i] === '\n') {
                currentLine++;
                if (currentLine === lineNum) {
                    return i + 1;
                }
            }
        }
        
        return text.length;
    }
    
    getLineLength(lineNum) {
        const text = this.getText();
        const lines = text.split('\n');
        return lines[lineNum] ? lines[lineNum].length : 0;
    }
    
    getTotalLines() {
        const text = this.getText();
        return text.split('\n').length;
    }
    
    moveCursorToPosition(targetPosition) {
        const currentPos = this.gapStart;
        
        if (targetPosition < currentPos) {
            for (let i = currentPos; i > targetPosition; i--) {
                this.moveCursorLeft();
            }
        } else if (targetPosition > currentPos) {
            for (let i = currentPos; i < targetPosition; i++) {
                this.moveCursorRight();
            }
        }
    }
    
    moveCursorUp() {
        const currentPos = this.getCurrentPosition();
        if (currentPos.line > 0) {
            const targetLine = currentPos.line - 1;
            const lineLength = this.getLineLength(targetLine);
            const targetColumn = Math.min(this.preferredColumn, lineLength);
            const targetPosition = this.getLineStartPosition(targetLine) + targetColumn;
            
            this.moveCursorToPosition(targetPosition);
        }
    }
    
    moveCursorDown() {
        const currentPos = this.getCurrentPosition();
        const totalLines = this.getTotalLines();
        
        if (currentPos.line < totalLines - 1) {
            const targetLine = currentPos.line + 1;
            const lineLength = this.getLineLength(targetLine);
            const targetColumn = Math.min(this.preferredColumn, lineLength);
            const targetPosition = this.getLineStartPosition(targetLine) + targetColumn;
            
            this.moveCursorToPosition(targetPosition);
        }
    }
    
    insert(char) {
        if (this.gapStart < this.gapEnd) {
            this.buffer[this.gapStart++] = char;
        } else {
            this.expandBuffer();
            this.buffer[this.gapStart++] = char;
        }
        this.updatePreferredColumn();
    }
    
    expandBuffer() {
        const newSize = this.buffer.length * 2;
        const newBuffer = new Array(newSize).fill('');
        
        // Copy text before gap
        for (let i = 0; i < this.gapStart; i++) {
            newBuffer[i] = this.buffer[i];
        }
        
        // Copy text after gap to end of new buffer
        const afterGapLength = this.buffer.length - this.gapEnd;
        for (let i = 0; i < afterGapLength; i++) {
            newBuffer[newSize - afterGapLength + i] = this.buffer[this.gapEnd + i];
        }
        
        this.buffer = newBuffer;
        this.gapEnd = newSize - afterGapLength;
    }
    
    delete() {
        if (this.gapStart > 0) {
            this.gapStart--;
            this.updatePreferredColumn();
        }
    }
    
    getText() {
        return this.buffer.slice(0, this.gapStart).join('')
             + this.buffer.slice(this.gapEnd).join('');
    }
    
    getDisplayText() {
        const beforeCursor = this.buffer.slice(0, this.gapStart).join('');
        const afterCursor = this.buffer.slice(this.gapEnd).join('');
        return beforeCursor + '_' + afterCursor;
    }
}

// Setup
const buffer = new GapBuffer(32);
const editor = document.getElementById("editor");
const info = document.getElementById("info");
const bufferDisplay = document.getElementById("bufferDisplay");
const bufferStats = document.getElementById("bufferStats");

function escapeChar(char) {
    if (char === '') return '∅';
    if (char === '\n') return '↵';
    if (char === '\t') return '→';
    if (char === ' ') return '·';
    return char;
}

function updateBufferVisualization() {
    bufferDisplay.innerHTML = '';
    
    // Show only first 50 positions to keep it manageable
    const maxShow = Math.min(buffer.buffer.length, 50);
    
    for (let i = 0; i < maxShow; i++) {
        const cell = document.createElement('div');
        cell.className = 'buffer-cell';
        
        if (i >= buffer.gapStart && i < buffer.gapEnd) {
            // Gap area
            cell.className += ' gap';
            cell.textContent = '∅';
            cell.title = `Gap position ${i}`;
        } else {
            // Text area
            cell.className += ' text';
            const char = buffer.buffer[i];
            cell.textContent = escapeChar(char);
            cell.title = `Position ${i}: "${char}"`;
        }
        
        // Mark cursor position
        if (i === buffer.gapStart) {
            cell.className += ' cursor';
            cell.title += ' (CURSOR)';
        }
        
        bufferDisplay.appendChild(cell);
    }
    
    // Add ellipsis if buffer is longer
    if (buffer.buffer.length > maxShow) {
        const ellipsis = document.createElement('div');
        ellipsis.textContent = '...';
        ellipsis.style.alignSelf = 'center';
        ellipsis.style.margin = '0 10px';
        bufferDisplay.appendChild(ellipsis);
    }
}

function updateStats() {
    const pos = buffer.getCurrentPosition();
    const gapSize = buffer.gapEnd - buffer.gapStart;
    const efficiency = ((buffer.length / buffer.buffer.length) * 100).toFixed(1);
    
    bufferStats.innerHTML = `
        <strong>Buffer Stats:</strong><br>
        Total buffer size: ${buffer.buffer.length} | Text length: ${buffer.length} | Gap size: ${gapSize}<br>
        Gap range: [${buffer.gapStart}, ${buffer.gapEnd}) | Space efficiency: ${efficiency}%<br>
        Cursor: line ${pos.line}, column ${pos.column} | Preferred column: ${buffer.preferredColumn}
    `;
}

function updateDisplay() {
    editor.textContent = buffer.getDisplayText();
    const pos = buffer.getCurrentPosition();
    info.textContent = `Cursor: line ${pos.line}, col ${pos.column} | Buffer pos: ${buffer.gapStart} | Length: ${buffer.length}`;
    updateBufferVisualization();
    updateStats();
}


editor.addEventListener("keydown", (e) => {
    if (e.key === "ArrowLeft") {
        e.preventDefault();
        buffer.moveCursorLeft();
        updateDisplay();
    } else if (e.key === "ArrowRight") {
        e.preventDefault();
        buffer.moveCursorRight();
        updateDisplay();
    } else if (e.key === "ArrowUp") {
        e.preventDefault();
        buffer.moveCursorUp();
        updateDisplay();
    } else if (e.key === "ArrowDown") {
        e.preventDefault();
        buffer.moveCursorDown();
        updateDisplay();
    } else if (e.key === "Backspace") {
        e.preventDefault();
        buffer.delete();
        updateDisplay();
    } else if (e.key === "Enter") {
        e.preventDefault();
        buffer.insert('\n');
        updateDisplay();
    } else if (e.key === "Tab") {
        e.preventDefault();
        buffer.insert('\t');
        updateDisplay();
    } else if (e.key.length === 1 && !e.ctrlKey && !e.metaKey) {
        e.preventDefault();
        buffer.insert(e.key);
        updateDisplay();
    }
});


editor.addEventListener("paste", (e) => {
    e.preventDefault();
    const pastedText = e.clipboardData.getData('text');
    for (let char of pastedText) {
        buffer.insert(char);
    }
    updateDisplay();
});


editor.addEventListener("click", () => {
    editor.focus();
});


editor.focus();


updateDisplay();
</script>
</body>
</html>
