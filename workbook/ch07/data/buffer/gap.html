<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Gap Buffer Editor</title>
    <style>
        body { font-family: monospace; padding: 1em; }
        #editor {
            white-space: pre-wrap;
            border: 2px solid #ccc;
            padding: 10px;
            width: 600px;
            height: 200px;
            overflow-y: auto;
            outline: none;
            word-wrap: break-word;
            background-color: white;
            cursor: text;
            position: relative;
        }
        #editor:focus {
            border-color: #007acc;
            background-color: #fafafa;
        }
        #info {
            margin-top: 1em;
        }
        .cursor {
            background-color: black;
            animation: blink 1s infinite;
        }
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }
    </style>
</head>
<body>
<h2>Gap Buffer Editor</h2>
<p><strong>Click in the editor box below and start typing!</strong></p>
<div id="editor" contenteditable="false" tabindex="0"></div>
<div id="info"></div>
<div style="margin-top: 1em;">
    <h3>Raw Buffer View:</h3>
    <textarea id="rawBuffer" readonly rows="8" cols="80" style="font-family: monospace; background-color: #f5f5f5;"></textarea>
</div>

<script>
class GapBuffer {
    constructor(size = 1024) {
        this.buffer = new Array(size).fill('');
        this.gapStart = 0;
        this.gapEnd = size;
        this.preferredColumn = 0;
    }
    
    get length() {
        return this.buffer.length - (this.gapEnd - this.gapStart);
    }
    
    moveCursorLeft() {
        if (this.gapStart > 0) {
            this.gapEnd--;
            this.buffer[this.gapEnd] = this.buffer[--this.gapStart];
            this.updatePreferredColumn();
        }
    }
    
    moveCursorRight() {
        if (this.gapEnd < this.buffer.length) {
            this.buffer[this.gapStart++] = this.buffer[this.gapEnd];
            this.gapEnd++;
            this.updatePreferredColumn();
        }
    }
    
    updatePreferredColumn() {
        const position = this.getCurrentPosition();
        this.preferredColumn = position.column;
    }
    
    getCurrentPosition() {
        const text = this.getText();
        let line = 0;
        let column = 0;
        
        for (let i = 0; i < this.gapStart; i++) {
            if (text[i] === '\n') {
                line++;
                column = 0;
            } else {
                column++;
            }
        }
        
        return { line, column };
    }
    
    getLineStartPosition(lineNum) {
        const text = this.getText();
        let currentLine = 0;
        let position = 0;
        
        if (lineNum === 0) return 0;
        
        for (let i = 0; i < text.length; i++) {
            if (text[i] === '\n') {
                currentLine++;
                if (currentLine === lineNum) {
                    return i + 1;
                }
            }
        }
        
        return text.length;
    }
    
    getLineLength(lineNum) {
        const text = this.getText();
        const lines = text.split('\n');
        return lines[lineNum] ? lines[lineNum].length : 0;
    }
    
    getTotalLines() {
        const text = this.getText();
        return text.split('\n').length;
    }
    
    moveCursorToPosition(targetPosition) {
        const currentPos = this.gapStart;
        
        if (targetPosition < currentPos) {
            // Move left
            for (let i = currentPos; i > targetPosition; i--) {
                this.moveCursorLeft();
            }
        } else if (targetPosition > currentPos) {
            // Move right
            for (let i = currentPos; i < targetPosition; i++) {
                this.moveCursorRight();
            }
        }
    }
    
    moveCursorUp() {
        const currentPos = this.getCurrentPosition();
        if (currentPos.line > 0) {
            const targetLine = currentPos.line - 1;
            const lineLength = this.getLineLength(targetLine);
            const targetColumn = Math.min(this.preferredColumn, lineLength);
            const targetPosition = this.getLineStartPosition(targetLine) + targetColumn;
            
            this.moveCursorToPosition(targetPosition);
        }
    }
    
    moveCursorDown() {
        const currentPos = this.getCurrentPosition();
        const totalLines = this.getTotalLines();
        
        if (currentPos.line < totalLines - 1) {
            const targetLine = currentPos.line + 1;
            const lineLength = this.getLineLength(targetLine);
            const targetColumn = Math.min(this.preferredColumn, lineLength);
            const targetPosition = this.getLineStartPosition(targetLine) + targetColumn;
            
            this.moveCursorToPosition(targetPosition);
        }
    }
    
    insert(char) {
        if (this.gapStart < this.gapEnd) {
            this.buffer[this.gapStart++] = char;
        } else {
            this.expandBuffer();
            this.buffer[this.gapStart++] = char;
        }
        this.updatePreferredColumn();
    }
    
    expandBuffer() {
        const newSize = this.buffer.length * 2;
        const newBuffer = new Array(newSize).fill('');
        
        // Copy text before gap
        for (let i = 0; i < this.gapStart; i++) {
            newBuffer[i] = this.buffer[i];
        }
        
        // Copy text after gap to end of new buffer
        const afterGapLength = this.buffer.length - this.gapEnd;
        for (let i = 0; i < afterGapLength; i++) {
            newBuffer[newSize - afterGapLength + i] = this.buffer[this.gapEnd + i];
        }
        
        this.buffer = newBuffer;
        this.gapEnd = newSize - afterGapLength;
    }
    
    delete() {
        if (this.gapStart > 0) {
            this.gapStart--;
            this.updatePreferredColumn();
        }
    }
    
    getText() {
        return this.buffer.slice(0, this.gapStart).join('')
             + this.buffer.slice(this.gapEnd).join('');
    }
    
    getDisplayText() {
        const beforeCursor = this.buffer.slice(0, this.gapStart).join('');
        const afterCursor = this.buffer.slice(this.gapEnd).join('');
        return beforeCursor + '|' + afterCursor;
    }
    
    getRawBufferView() {
        const escapeChar = (char) => {
            if (char === '') return '∅';
            if (char === '\n') return '\\n';
            if (char === '\t') return '\\t';
            if (char === ' ') return '·';
            return char;
        };
        
        let result = 'Buffer contents (gap marked with [ ]):\n';
        result += 'Position: ';
        for (let i = 0; i < Math.min(this.buffer.length, 50); i++) {
            if (i < 10) result += i + ' ';
            else result += (i % 10) + ' ';
        }
        result += '\n';
        result += 'Content:  ';
        
        for (let i = 0; i < Math.min(this.buffer.length, 50); i++) {
            if (i === this.gapStart) result += '[';
            if (i === this.gapEnd) result += ']';
            result += escapeChar(this.buffer[i]) + ' ';
        }
        
        if (this.gapEnd === this.buffer.length) result += ']';
        
        const pos = this.getCurrentPosition();
        result += '\n\nGap: start=' + this.gapStart + ', end=' + this.gapEnd + ', size=' + (this.gapEnd - this.gapStart);
        result += '\nCursor: line=' + pos.line + ', column=' + pos.column + ', preferred=' + this.preferredColumn;
        result += '\nText length: ' + this.length;
        result += '\nActual text: "' + this.getText().replace(/\n/g, '\\n').replace(/\t/g, '\\t') + '"';
        
        return result;
    }
}

// Setup
const buffer = new GapBuffer(64);
const editor = document.getElementById("editor");
const info = document.getElementById("info");
const rawBuffer = document.getElementById("rawBuffer");

function updateDisplay() {
    editor.textContent = buffer.getDisplayText();
    const pos = buffer.getCurrentPosition();
    info.textContent = `Cursor: line ${pos.line}, col ${pos.column} | Buffer pos: ${buffer.gapStart} | Length: ${buffer.length}`;
    rawBuffer.value = buffer.getRawBufferView();
}

// Handle all keyboard input
editor.addEventListener("keydown", (e) => {
    console.log("Key pressed:", e.key); // Debug log
    
    if (e.key === "ArrowLeft") {
        e.preventDefault();
        buffer.moveCursorLeft();
        updateDisplay();
    } else if (e.key === "ArrowRight") {
        e.preventDefault();
        buffer.moveCursorRight();
        updateDisplay();
    } else if (e.key === "ArrowUp") {
        e.preventDefault();
        buffer.moveCursorUp();
        updateDisplay();
    } else if (e.key === "ArrowDown") {
        e.preventDefault();
        buffer.moveCursorDown();
        updateDisplay();
    } else if (e.key === "Backspace") {
        e.preventDefault();
        buffer.delete();
        updateDisplay();
    } else if (e.key === "Enter") {
        e.preventDefault();
        buffer.insert('\n');
        updateDisplay();
    } else if (e.key === "Tab") {
        e.preventDefault();
        buffer.insert('\t');
        updateDisplay();
    } else if (e.key.length === 1 && !e.ctrlKey && !e.metaKey) {
        e.preventDefault();
        buffer.insert(e.key);
        updateDisplay();
    }
});

// Handle paste events
editor.addEventListener("paste", (e) => {
    e.preventDefault();
    const pastedText = e.clipboardData.getData('text');
    for (let char of pastedText) {
        buffer.insert(char);
    }
    updateDisplay();
});

// Make sure editor can receive focus
editor.addEventListener("click", () => {
    editor.focus();
});

// Auto-focus the editor when page loads
editor.focus();

// Initial display
updateDisplay();
</script>
</body>
</html>