<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Ocean with Flying Birb</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #87CEEB 0%, #4682B4 50%, #191970 100%);
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        
        #canvas {
            display: block;
            cursor: grab;
        }
        
        #canvas:active {
            cursor: grabbing;
        }
        
        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0,0,0,0.3);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }
        
        .control-group {
            margin-bottom: 10px;
        }
        
        label {
            display: inline-block;
            width: 120px;
            font-size: 14px;
        }
        
        input[type="range"] {
            width: 100px;
        }
        
        .bird-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            background: rgba(0,0,0,0.3);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }
        
        .flight-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            font-size: 12px;
            background: rgba(0,0,0,0.3);
            padding: 10px;
            border-radius: 5px;
        }
        
        .info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: white;
            font-size: 12px;
            background: rgba(0,0,0,0.3);
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div class="controls">
        <div class="control-group">
            <label>Wave Height:</label>
            <input type="range" id="amplitude" min="0.1" max="3" step="0.1" value="1.5">
        </div>
        <div class="control-group">
            <label>Wave Speed:</label>
            <input type="range" id="speed" min="0.1" max="3" step="0.1" value="1">
        </div>
        <div class="control-group">
            <label>Wave Length:</label>
            <input type="range" id="frequency" min="0.1" max="2" step="0.1" value="0.8">
        </div>
        <div class="control-group">
            <label>Complexity:</label>
            <input type="range" id="complexity" min="1" max="4" step="1" value="2">
        </div>
    </div>
    
    <div class="bird-controls">
        <h4 style="margin-top: 0;">Bird Controls</h4>
        <div class="control-group">
            <label>Follow Bird:</label>
            <input type="checkbox" id="followBird" checked>
        </div>
        <div class="control-group">
            <label>Auto Flight:</label>
            <input type="checkbox" id="autoFlight" checked>
        </div>
        <div class="control-group">
            <label>Speed:</label>
            <input type="range" id="birdSpeed" min="0.5" max="3" step="0.1" value="1.5">
        </div>
        <div class="control-group">
            <label>Height:</label>
            <input type="range" id="birdHeight" min="2" max="15" step="0.5" value="8">
        </div>
    </div>
    
    <div class="flight-info">
        <div>Bird Position: <span id="birdPos">0, 0</span></div>
        <div>Altitude: <span id="altitude">0</span>m</div>
        <div>Speed: <span id="flightSpeed">0</span> km/h</div>
    </div>
    
    <div class="info">
        Arrow Keys: Manual Control<br>
        Drag: Rotate View â€¢ Scroll: Zoom<br>
        Space: Toggle Auto Flight
    </div>

    <script>
        class Ocean3D {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.width = window.innerWidth;
                this.height = window.innerHeight;
                
                this.canvas.width = this.width;
                this.canvas.height = this.height;
                
                // Camera settings
                this.camera = {
                    x: 0,
                    y: 5,
                    z: -15,
                    rotX: -0.3,
                    rotY: 0,
                    fov: 800
                };
                
                // Bird object
                this.bird = {
                    x: 0,
                    y: 8,
                    z: 5,
                    velocityX: 0,
                    velocityY: 0,
                    velocityZ: 0,
                    tilt: 0,
                    wingFlap: 0,
                    size: 0.8,
                    color: [255, 255, 255],
                    speed: 1.5,
                    autoFlight: true,
                    targetX: 0,
                    targetZ: 0,
                    flightPath: 0
                };
                
                // Wave parameters
                this.waveParams = {
                    amplitude: 1.5,
                    frequency: 0.8,
                    speed: 1,
                    complexity: 2
                };
                
                // Procedural generation based on bird position
                this.proceduralSeed = {
                    offsetX: 0,
                    offsetZ: 0,
                    turbulence: 1
                };
                
                this.time = 0;
                this.gridSize = 80;
                this.scale = 0.8;
                this.fogDistance = 30;
                
                // Input handling
                this.keys = {};
                this.mouse = {
                    x: 0,
                    y: 0,
                    isDown: false,
                    lastX: 0,
                    lastY: 0
                };
                
                this.followBird = true;
                
                this.setupEventListeners();
                this.animate();
            }
            
            setupEventListeners() {
                // Mouse controls
                this.canvas.addEventListener('mousedown', (e) => {
                    this.mouse.isDown = true;
                    this.mouse.lastX = e.clientX;
                    this.mouse.lastY = e.clientY;
                });
                
                this.canvas.addEventListener('mousemove', (e) => {
                    if (this.mouse.isDown && !this.followBird) {
                        const deltaX = e.clientX - this.mouse.lastX;
                        const deltaY = e.clientY - this.mouse.lastY;
                        
                        this.camera.rotY += deltaX * 0.01;
                        this.camera.rotX += deltaY * 0.01;
                        
                        this.camera.rotX = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.camera.rotX));
                        
                        this.mouse.lastX = e.clientX;
                        this.mouse.lastY = e.clientY;
                    }
                });
                
                this.canvas.addEventListener('mouseup', () => {
                    this.mouse.isDown = false;
                });
                
                this.canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    if (!this.followBird) {
                        this.camera.z += e.deltaY * 0.01;
                        this.camera.z = Math.max(-50, Math.min(-5, this.camera.z));
                    }
                });
                
                // Keyboard controls
                document.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;
                    if (e.code === 'Space') {
                        e.preventDefault();
                        this.bird.autoFlight = !this.bird.autoFlight;
                        document.getElementById('autoFlight').checked = this.bird.autoFlight;
                    }
                });
                
                document.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                });
                
                // UI controls
                document.getElementById('amplitude').addEventListener('input', (e) => {
                    this.waveParams.amplitude = parseFloat(e.target.value);
                });
                
                document.getElementById('speed').addEventListener('input', (e) => {
                    this.waveParams.speed = parseFloat(e.target.value);
                });
                
                document.getElementById('frequency').addEventListener('input', (e) => {
                    this.waveParams.frequency = parseFloat(e.target.value);
                });
                
                document.getElementById('complexity').addEventListener('input', (e) => {
                    this.waveParams.complexity = parseInt(e.target.value);
                });
                
                document.getElementById('followBird').addEventListener('change', (e) => {
                    this.followBird = e.target.checked;
                });
                
                document.getElementById('autoFlight').addEventListener('change', (e) => {
                    this.bird.autoFlight = e.target.checked;
                });
                
                document.getElementById('birdSpeed').addEventListener('input', (e) => {
                    this.bird.speed = parseFloat(e.target.value);
                });
                
                document.getElementById('birdHeight').addEventListener('input', (e) => {
                    this.bird.y = parseFloat(e.target.value);
                });
                
                window.addEventListener('resize', () => {
                    this.width = window.innerWidth;
                    this.height = window.innerHeight;
                    this.canvas.width = this.width;
                    this.canvas.height = this.height;
                });
            }
            
            updateBird() {
                // Manual controls when not in auto flight
                if (!this.bird.autoFlight) {
                    const acceleration = 0.02;
                    if (this.keys['ArrowUp']) this.bird.velocityZ += acceleration;
                    if (this.keys['ArrowDown']) this.bird.velocityZ -= acceleration;
                    if (this.keys['ArrowLeft']) {
                        this.bird.velocityX -= acceleration;
                        this.bird.tilt = Math.max(-0.3, this.bird.tilt - 0.02);
                    }
                    if (this.keys['ArrowRight']) {
                        this.bird.velocityX += acceleration;
                        this.bird.tilt = Math.min(0.3, this.bird.tilt + 0.02);
                    }
                    if (this.keys['KeyW']) this.bird.velocityY += acceleration * 0.5;
                    if (this.keys['KeyS']) this.bird.velocityY -= acceleration * 0.5;
                } else {
                    // Auto flight pattern
                    this.bird.flightPath += 0.01;
                    this.bird.targetX = Math.sin(this.bird.flightPath * 0.7) * 15 + Math.cos(this.bird.flightPath * 0.3) * 8;
                    this.bird.targetZ = Math.cos(this.bird.flightPath * 0.5) * 12 + Math.sin(this.bird.flightPath * 0.2) * 6;
                    
                    const targetY = 8 + Math.sin(this.bird.flightPath * 1.2) * 3;
                    
                    // Smooth movement towards targets
                    const dx = this.bird.targetX - this.bird.x;
                    const dy = targetY - this.bird.y;
                    const dz = this.bird.targetZ - this.bird.z;
                    
                    this.bird.velocityX += dx * 0.001;
                    this.bird.velocityY += dy * 0.001;
                    this.bird.velocityZ += dz * 0.001;
                    
                    // Banking in turns
                    this.bird.tilt = Math.max(-0.4, Math.min(0.4, dx * 0.05));
                }
                
                // Apply physics
                const drag = 0.98;
                this.bird.velocityX *= drag;
                this.bird.velocityY *= drag;
                this.bird.velocityZ *= drag;
                
                // Speed limiting
                const maxSpeed = this.bird.speed * 0.1;
                const speed = Math.sqrt(this.bird.velocityX**2 + this.bird.velocityY**2 + this.bird.velocityZ**2);
                if (speed > maxSpeed) {
                    this.bird.velocityX = (this.bird.velocityX / speed) * maxSpeed;
                    this.bird.velocityY = (this.bird.velocityY / speed) * maxSpeed;
                    this.bird.velocityZ = (this.bird.velocityZ / speed) * maxSpeed;
                }
                
                // Update position
                this.bird.x += this.bird.velocityX;
                this.bird.y += this.bird.velocityY;
                this.bird.z += this.bird.velocityZ;
                
                // Wing flapping
                this.bird.wingFlap += 0.3 + speed * 2;
                
                // Tilt decay when not turning
                if (this.bird.autoFlight || (!this.keys['ArrowLeft'] && !this.keys['ArrowRight'])) {
                    this.bird.tilt *= 0.95;
                }
                
                // Update procedural generation based on bird position
                this.proceduralSeed.offsetX = this.bird.x * 0.1;
                this.proceduralSeed.offsetZ = this.bird.z * 0.1;
                this.proceduralSeed.turbulence = 1 + Math.abs(this.bird.velocityX + this.bird.velocityZ) * 5;
                
                // Update camera to follow bird
                if (this.followBird) {
                    this.camera.x = this.bird.x - Math.sin(this.camera.rotY) * 15;
                    this.camera.y = this.bird.y + 3;
                    this.camera.z = this.bird.z - Math.cos(this.camera.rotY) * 15;
                    
                    // Smooth camera tracking
                    const lookAtX = this.bird.x - this.camera.x;
                    const lookAtZ = this.bird.z - this.camera.z;
                    const targetRotY = Math.atan2(lookAtX, lookAtZ);
                    this.camera.rotY += (targetRotY - this.camera.rotY) * 0.05;
                }
                
                // Update UI
                document.getElementById('birdPos').textContent = `${this.bird.x.toFixed(1)}, ${this.bird.z.toFixed(1)}`;
                document.getElementById('altitude').textContent = Math.max(0, this.bird.y - this.getWaveHeight(this.bird.x, this.bird.z, this.time)).toFixed(1);
                document.getElementById('flightSpeed').textContent = (speed * 100).toFixed(0);
            }
            
            getWaveHeight(x, z, time) {
                let height = 0;
                const complexity = this.waveParams.complexity;
                
                // Add procedural offsets based on bird position
                const procX = x + this.proceduralSeed.offsetX;
                const procZ = z + this.proceduralSeed.offsetZ;
                const turbulence = this.proceduralSeed.turbulence;
                
                // Main waves with procedural variation
                height += Math.sin(procX * this.waveParams.frequency + time * this.waveParams.speed) * this.waveParams.amplitude * 0.7;
                height += Math.sin(procZ * this.waveParams.frequency * 0.7 + time * this.waveParams.speed * 0.8) * this.waveParams.amplitude * 0.6;
                
                if (complexity >= 2) {
                    height += Math.sin(procX * this.waveParams.frequency * 2.3 + procZ * 0.5 + time * this.waveParams.speed * 1.2) * this.waveParams.amplitude * 0.25 * turbulence;
                    height += Math.cos(procZ * this.waveParams.frequency * 1.7 - procX * 0.3 + time * this.waveParams.speed * 0.9) * this.waveParams.amplitude * 0.35;
                }
                
                if (complexity >= 3) {
                    height += Math.sin(procX * this.waveParams.frequency * 4 + time * this.waveParams.speed * 2) * this.waveParams.amplitude * 0.12 * turbulence;
                    height += Math.cos(procZ * this.waveParams.frequency * 3.5 + time * this.waveParams.speed * 1.5) * this.waveParams.amplitude * 0.18;
                }
                
                if (complexity >= 4) {
                    height += Math.sin((procX + procZ) * this.waveParams.frequency * 6 + time * this.waveParams.speed * 3) * this.waveParams.amplitude * 0.07 * turbulence;
                    height += Math.cos((procX - procZ) * this.waveParams.frequency * 5 + time * this.waveParams.speed * 2.5) * this.waveParams.amplitude * 0.09;
                }
                
                return height;
            }
            
            project3D(x, y, z) {
                const cosX = Math.cos(this.camera.rotX);
                const sinX = Math.sin(this.camera.rotX);
                const cosY = Math.cos(this.camera.rotY);
                const sinY = Math.sin(this.camera.rotY);
                
                x -= this.camera.x;
                y -= this.camera.y;
                z -= this.camera.z;
                
                let tempX = x * cosY - z * sinY;
                let tempZ = x * sinY + z * cosY;
                x = tempX;
                z = tempZ;
                
                let tempY = y * cosX - z * sinX;
                tempZ = y * sinX + z * cosX;
                y = tempY;
                z = tempZ;
                
                if (z <= 0) return null;
                
                const scale = this.camera.fov / z;
                return {
                    x: this.width / 2 + x * scale,
                    y: this.height / 2 - y * scale,
                    z: z
                };
            }
            
            getWaveColor(height, x, z, normalizedHeight, depth) {
                const deepBlue = [8, 48, 107];
                const oceanBlue = [13, 94, 175];
                const lightBlue = [52, 152, 219];
                const foam = [220, 240, 255];
                
                let color;
                
                if (normalizedHeight > 0.7) {
                    const t = (normalizedHeight - 0.7) / 0.3;
                    color = [
                        lightBlue[0] + (foam[0] - lightBlue[0]) * t,
                        lightBlue[1] + (foam[1] - lightBlue[1]) * t,
                        lightBlue[2] + (foam[2] - lightBlue[2]) * t
                    ];
                } else if (normalizedHeight > 0.3) {
                    const t = (normalizedHeight - 0.3) / 0.4;
                    color = [
                        oceanBlue[0] + (lightBlue[0] - oceanBlue[0]) * t,
                        oceanBlue[1] + (lightBlue[1] - oceanBlue[1]) * t,
                        oceanBlue[2] + (lightBlue[2] - oceanBlue[2]) * t
                    ];
                } else {
                    const t = normalizedHeight / 0.3;
                    color = [
                        deepBlue[0] + (oceanBlue[0] - deepBlue[0]) * t,
                        deepBlue[1] + (oceanBlue[1] - deepBlue[1]) * t,
                        deepBlue[2] + (oceanBlue[2] - deepBlue[2]) * t
                    ];
                }
                
                const fogFactor = Math.min(1, Math.max(0, (depth - 10) / this.fogDistance));
                const backgroundColor = [71, 130, 180];
                color = [
                    color[0] + (backgroundColor[0] - color[0]) * fogFactor,
                    color[1] + (backgroundColor[1] - color[1]) * fogFactor,
                    color[2] + (backgroundColor[2] - color[2]) * fogFactor
                ];
                
                return `rgb(${Math.round(color[0])}, ${Math.round(color[1])}, ${Math.round(color[2])})`;
            }
            
            renderBird() {
                const wingFlap = Math.sin(this.bird.wingFlap) * 0.5;
                
                // Bird geometry - made of triangles
                const birdGeometry = [
                    // Body (main triangle)
                    {
                        points: [
                            { x: 0, y: 0, z: 0.5 },
                            { x: -0.3, y: 0, z: -0.5 },
                            { x: 0.3, y: 0, z: -0.5 }
                        ],
                        color: [240, 240, 240]
                    },
                    // Left wing
                    {
                        points: [
                            { x: -0.3, y: wingFlap * 0.5, z: 0 },
                            { x: -1.2, y: wingFlap, z: -0.2 },
                            { x: -0.8, y: wingFlap * 0.3, z: 0.3 }
                        ],
                        color: [220, 220, 220]
                    },
                    // Right wing
                    {
                        points: [
                            { x: 0.3, y: wingFlap * 0.5, z: 0 },
                            { x: 1.2, y: wingFlap, z: -0.2 },
                            { x: 0.8, y: wingFlap * 0.3, z: 0.3 }
                        ],
                        color: [220, 220, 220]
                    },
                    // Tail
                    {
                        points: [
                            { x: 0, y: 0.1, z: -0.5 },
                            { x: -0.2, y: 0, z: -0.8 },
                            { x: 0.2, y: 0, z: -0.8 }
                        ],
                        color: [200, 200, 200]
                    }
                ];
                
                // Transform and project bird geometry
                const projectedBird = [];
                
                birdGeometry.forEach(part => {
                    const projectedPart = {
                        points: [],
                        color: part.color,
                        avgZ: 0
                    };
                    
                    part.points.forEach(point => {
                        // Apply bird transformations
                        let x = point.x * this.bird.size;
                        let y = point.y * this.bird.size;
                        let z = point.z * this.bird.size;
                        
                        // Apply tilt (banking)
                        const cosTilt = Math.cos(this.bird.tilt);
                        const sinTilt = Math.sin(this.bird.tilt);
                        const tempX = x * cosTilt - y * sinTilt;
                        const tempY = x * sinTilt + y * cosTilt;
                        x = tempX;
                        y = tempY;
                        
                        // Translate to bird position
                        x += this.bird.x;
                        y += this.bird.y;
                        z += this.bird.z;
                        
                        const projected = this.project3D(x, y, z);
                        if (projected) {
                            projectedPart.points.push(projected);
                            projectedPart.avgZ += projected.z;
                        }
                    });
                    
                    if (projectedPart.points.length === 3) {
                        projectedPart.avgZ /= 3;
                        projectedBird.push(projectedPart);
                    }
                });
                
                // Sort by depth and render
                projectedBird.sort((a, b) => b.avgZ - a.avgZ);
                
                projectedBird.forEach(part => {
                    this.ctx.fillStyle = `rgb(${part.color[0]}, ${part.color[1]}, ${part.color[2]})`;
                    this.ctx.strokeStyle = `rgb(${part.color[0] - 20}, ${part.color[1] - 20}, ${part.color[2] - 20})`;
                    this.ctx.lineWidth = 1;
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(part.points[0].x, part.points[0].y);
                    this.ctx.lineTo(part.points[1].x, part.points[1].y);
                    this.ctx.lineTo(part.points[2].x, part.points[2].y);
                    this.ctx.closePath();
                    this.ctx.fill();
                    this.ctx.stroke();
                });
            }
            
            render() {
                this.ctx.clearRect(0, 0, this.width, this.height);
                
                const gridPoints = [];
                const range = 40;
                const step = range / this.gridSize;
                
                let minHeight = Infinity;
                let maxHeight = -Infinity;
                
                // Generate grid points around bird position for better performance
                const centerX = this.followBird ? this.bird.x : this.camera.x;
                const centerZ = this.followBird ? this.bird.z : this.camera.z;
                
                for (let i = 0; i <= this.gridSize; i++) {
                    gridPoints[i] = [];
                    for (let j = 0; j <= this.gridSize; j++) {
                        const x = centerX + (i - this.gridSize / 2) * step;
                        const z = centerZ + (j - this.gridSize / 2) * step;
                        const y = this.getWaveHeight(x, z, this.time);
                        
                        minHeight = Math.min(minHeight, y);
                        maxHeight = Math.max(maxHeight, y);
                        
                        gridPoints[i][j] = { x, y, z };
                    }
                }
                
                const faces = [];
                
                for (let i = 0; i < this.gridSize; i++) {
                    for (let j = 0; j < this.gridSize; j++) {
                        const p1 = gridPoints[i][j];
                        const p2 = gridPoints[i + 1][j];
                        const p3 = gridPoints[i][j + 1];
                        const p4 = gridPoints[i + 1][j + 1];
                        
                        faces.push({
                            points: [p1, p2, p3],
                            avgZ: (p1.z + p2.z + p3.z) / 3,
                            avgHeight: (p1.y + p2.y + p3.y) / 3
                        });
                        
                        faces.push({
                            points: [p2, p4, p3],
                            avgZ: (p2.z + p4.z + p3.z) / 3,
                            avgHeight: (p2.y + p4.y + p3.y) / 3
                        });
                    }
                }
                
                faces.sort((a, b) => b.avgZ - a.avgZ);
                
                // Render ocean
                faces.forEach(face => {
                    const projectedPoints = face.points.map(p => this.project3D(p.x, p.y, p.z)).filter(p => p !== null);
                    
                    if (projectedPoints.length === 3) {
                        const colors = face.points.map((p, idx) => {
                            const normalizedHeight = (p.y - minHeight) / (maxHeight - minHeight);
                            const color = this.getWaveColor(p.y, p.x, p.z, normalizedHeight, projectedPoints[idx].z);
                            const rgb = color.match(/rgb\((\d+), (\d+), (\d+)\)/);
                            return [parseInt(rgb[1]), parseInt(rgb[2]), parseInt(rgb[3])];
                        });
                        
                        const gradient = this.ctx.createLinearGradient(
                            projectedPoints[0].x, projectedPoints[0].y,
                            projectedPoints[2].x, projectedPoints[2].y
                        );
                        gradient.addColorStop(0, `rgb(${colors[0][0]}, ${colors[0][1]}, ${colors[0][2]})`);
                        gradient.addColorStop(0.5, `rgb(${colors[1][0]}, ${colors[1][1]}, ${colors[1][2]})`);
                        gradient.addColorStop(1, `rgb(${colors[2][0]}, ${colors[2][1]}, ${colors[2][2]})`);
                        
                        this.ctx.fillStyle = gradient;
                        this.ctx.strokeStyle = gradient;
                        this.ctx.lineWidth = 0.2;
                        
                        this.ctx.beginPath();
                        this.ctx.moveTo(projectedPoints[0].x, projectedPoints[0].y);
                        this.ctx.lineTo(projectedPoints[1].x, projectedPoints[1].y);
                        this.ctx.lineTo(projectedPoints[2].x, projectedPoints[2].y);
                        this.ctx.closePath();
                        this.ctx.fill();
                        this.ctx.stroke();
                    }
                });
                
                // Render bird
                this.renderBird();
            }
            
            animate() {
                this.time += 0.02;
                this.updateBird();
                this.render();
                requestAnimationFrame(() => this.animate());
            }
        }
        
        // Initialize the ocean scene
        const ocean = new Ocean3D();
    </script>
</body>
</html>