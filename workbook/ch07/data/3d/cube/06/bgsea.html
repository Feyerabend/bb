<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Ocean Waves</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #87CEEB 0%, #4682B4 50%, #191970 100%);
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        
        #canvas {
            display: block;
            cursor: grab;
        }
        
        #canvas:active {
            cursor: grabbing;
        }
        
        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0,0,0,0.3);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }
        
        .control-group {
            margin-bottom: 10px;
        }
        
        label {
            display: inline-block;
            width: 120px;
            font-size: 14px;
        }
        
        input[type="range"] {
            width: 100px;
        }
        
        .info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: white;
            font-size: 12px;
            background: rgba(0,0,0,0.3);
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div class="controls">
        <div class="control-group">
            <label>Wave Height:</label>
            <input type="range" id="amplitude" min="0.1" max="3" step="0.1" value="1.5">
        </div>
        <div class="control-group">
            <label>Wave Speed:</label>
            <input type="range" id="speed" min="0.1" max="3" step="0.1" value="1">
        </div>
        <div class="control-group">
            <label>Wave Length:</label>
            <input type="range" id="frequency" min="0.1" max="2" step="0.1" value="0.8">
        </div>
        <div class="control-group">
            <label>Complexity:</label>
            <input type="range" id="complexity" min="1" max="4" step="1" value="2">
        </div>
    </div>
    
    <div class="info">
        Drag to rotate â€¢ Scroll to zoom
    </div>

    <script>
        class Ocean3D {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.width = window.innerWidth;
                this.height = window.innerHeight;
                
                this.canvas.width = this.width;
                this.canvas.height = this.height;
                
                // Camera settings with random initial drift
                this.camera = {
                    x: (Math.random() - 0.5) * 2,
                    y: 5 + (Math.random() - 0.5) * 1,
                    z: -15 + (Math.random() - 0.5) * 2,
                    rotX: -0.3 + (Math.random() - 0.5) * 0.1,
                    rotY: (Math.random() - 0.5) * 0.2,
                    fov: 800
                };
                
                // Wave parameters with randomized initial values
                this.waveParams = {
                    amplitude: 1.5 + (Math.random() - 0.5) * 0.5,
                    frequency: 0.8 + (Math.random() - 0.5) * 0.2,
                    speed: 1 + (Math.random() - 0.5) * 0.3,
                    complexity: Math.round(2 + Math.random() * 2)
                };
                
                // Random offsets for wave variations
                this.waveOffsets = {
                    offset1: Math.random() * Math.PI * 2,
                    offset2: Math.random() * Math.PI * 2,
                    offset3: Math.random() * Math.PI * 2,
                    offset4: Math.random() * Math.PI * 2
                };
                
                this.time = 0;
                this.gridSize = 100; // Increased for smoother waves
                this.scale = 0.8;
                this.fogDistance = 30; // Distance for fog effect
                
                // Mouse interaction
                this.mouse = {
                    x: 0,
                    y: 0,
                    isDown: false,
                    lastX: 0,
                    lastY: 0
                };
                
                // Random camera drift
                this.cameraDrift = {
                    rotX: (Math.random() - 0.5) * 0.001,
                    rotY: (Math.random() - 0.5) * 0.001,
                    speed: 0.0005
                };
                
                this.setupEventListeners();
                this.animate();
            }
            
            setupEventListeners() {
                this.canvas.addEventListener('mousedown', (e) => {
                    this.mouse.isDown = true;
                    this.mouse.lastX = e.clientX;
                    this.mouse.lastY = e.clientY;
                });
                
                this.canvas.addEventListener('mousemove', (e) => {
                    if (this.mouse.isDown) {
                        const deltaX = e.clientX - this.mouse.lastX;
                        const deltaY = e.clientY - this.mouse.lastY;
                        
                        this.camera.rotY += deltaX * 0.01;
                        this.camera.rotX += deltaY * 0.01;
                        
                        this.camera.rotX = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.camera.rotX));
                        
                        this.mouse.lastX = e.clientX;
                        this.mouse.lastY = e.clientY;
                    }
                });
                
                this.canvas.addEventListener('mouseup', () => {
                    this.mouse.isDown = false;
                });
                
                this.canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    this.camera.z += e.deltaY * 0.01;
                    this.camera.z = Math.max(-50, Math.min(-5, this.camera.z));
                });
                
                document.getElementById('amplitude').addEventListener('input', (e) => {
                    this.waveParams.amplitude = parseFloat(e.target.value);
                });
                
                document.getElementById('speed').addEventListener('input', (e) => {
                    this.waveParams.speed = parseFloat(e.target.value);
                });
                
                document.getElementById('frequency').addEventListener('input', (e) => {
                    this.waveParams.frequency = parseFloat(e.target.value);
                });
                
                document.getElementById('complexity').addEventListener('input', (e) => {
                    this.waveParams.complexity = parseInt(e.target.value);
                });
                
                window.addEventListener('resize', () => {
                    this.width = window.innerWidth;
                    this.height = window.innerHeight;
                    this.canvas.width = this.width;
                    this.canvas.height = this.height;
                });
            }
            
            // Generate smoother wave height
            getWaveHeight(x, z, time) {
                let height = 0;
                const complexity = this.waveParams.complexity;
                
                // Main wave with random offset and smoother transitions
                height += Math.sin(x * this.waveParams.frequency + time * this.waveParams.speed + this.waveOffsets.offset1) * this.waveParams.amplitude * 0.7;
                height += Math.sin(z * this.waveParams.frequency * 0.7 + time * this.waveParams.speed * 0.8 + this.waveOffsets.offset2) * this.waveParams.amplitude * 0.6;
                
                if (complexity >= 2) {
                    height += Math.sin(x * this.waveParams.frequency * (2.3 + (Math.random() - 0.5) * 0.2) + z * 0.5 + time * this.waveParams.speed * 1.2 + this.waveOffsets.offset3) * this.waveParams.amplitude * 0.25;
                    height += Math.cos(z * this.waveParams.frequency * (1.7 + (Math.random() - 0.5) * 0.2) - x * 0.3 + time * this.waveParams.speed * 0.9 + this.waveOffsets.offset4) * this.waveParams.amplitude * 0.35;
                }
                
                if (complexity >= 3) {
                    height += Math.sin(x * this.waveParams.frequency * (4 + (Math.random() - 0.5) * 0.3) + time * this.waveParams.speed * 2) * this.waveParams.amplitude * 0.12;
                    height += Math.cos(z * this.waveParams.frequency * (3.5 + (Math.random() - 0.5) * 0.3) + time * this.waveParams.speed * 1.5) * this.waveParams.amplitude * 0.18;
                }
                
                if (complexity >= 4) {
                    height += Math.sin((x + z) * this.waveParams.frequency * (6 + (Math.random() - 0.5) * 0.4) + time * this.waveParams.speed * 3) * this.waveParams.amplitude * 0.07;
                    height += Math.cos((x - z) * this.waveParams.frequency * (5 + (Math.random() - 0.5) * 0.4) + time * this.waveParams.speed * 2.5) * this.waveParams.amplitude * 0.09;
                }
                
                return height;
            }
            
            // 3D to 2D projection
            project3D(x, y, z) {
                const cosX = Math.cos(this.camera.rotX);
                const sinX = Math.sin(this.camera.rotX);
                const cosY = Math.cos(this.camera.rotY);
                const sinY = Math.sin(this.camera.rotY);
                
                x -= this.camera.x;
                y -= this.camera.y;
                z -= this.camera.z;
                
                let tempX = x * cosY - z * sinY;
                let tempZ = x * sinY + z * cosY;
                x = tempX;
                z = tempZ;
                
                let tempY = y * cosX - z * sinX;
                tempZ = y * sinX + z * cosX;
                y = tempY;
                z = tempZ;
                
                if (z <= 0) return null;
                
                const scale = this.camera.fov / z;
                return {
                    x: this.width / 2 + x * scale,
                    y: this.height / 2 - y * scale,
                    z: z
                };
            }
            
            // Get wave color with random tint and fog effect
            getWaveColor(height, x, z, normalizedHeight, depth) {
                const deepBlue = [8 + (Math.random() - 0.5) * 10, 48 + (Math.random() - 0.5) * 10, 107 + (Math.random() - 0.5) * 10];
                const oceanBlue = [13 + (Math.random() - 0.5) * 10, 94 + (Math.random() - 0.5) * 10, 175 + (Math.random() - 0.5) * 10];
                const lightBlue = [52 + (Math.random() - 0.5) * 10, 152 + (Math.random() - 0.5) * 10, 219 + (Math.random() - 0.5) * 10];
                const foam = [220 + (Math.random() - 0.5) * 10, 240 + (Math.random() - 0.5) * 10, 255 + (Math.random() - 0.5) * 10];
                
                let color;
                
                if (normalizedHeight > 0.7) {
                    const t = (normalizedHeight - 0.7) / 0.3;
                    color = [
                        lightBlue[0] + (foam[0] - lightBlue[0]) * t,
                        lightBlue[1] + (foam[1] - lightBlue[1]) * t,
                        lightBlue[2] + (foam[2] - lightBlue[2]) * t
                    ];
                } else if (normalizedHeight > 0.3) {
                    const t = (normalizedHeight - 0.3) / 0.4;
                    color = [
                        oceanBlue[0] + (lightBlue[0] - oceanBlue[0]) * t,
                        oceanBlue[1] + (lightBlue[1] - oceanBlue[1]) * t,
                        oceanBlue[2] + (lightBlue[2] - oceanBlue[2]) * t
                    ];
                } else {
                    const t = normalizedHeight / 0.3;
                    color = [
                        deepBlue[0] + (oceanBlue[0] - deepBlue[0]) * t,
                        deepBlue[1] + (oceanBlue[1] - deepBlue[1]) * t,
                        deepBlue[2] + (oceanBlue[2] - deepBlue[2]) * t
                    ];
                }
                
                // Apply fog effect based on depth
                const fogFactor = Math.min(1, Math.max(0, (depth - 10) / this.fogDistance));
                const backgroundColor = [71, 130, 180]; // Matches mid-point of background gradient
                color = [
                    color[0] + (backgroundColor[0] - color[0]) * fogFactor,
                    color[1] + (backgroundColor[1] - color[1]) * fogFactor,
                    color[2] + (backgroundColor[2] - color[2]) * fogFactor
                ];
                
                return `rgb(${Math.round(color[0])}, ${Math.round(color[1])}, ${Math.round(color[2])})`;
            }
            
            // Linear interpolation for smooth color transitions
            lerpColor(color1, color2, t) {
                return [
                    color1[0] + (color2[0] - color1[0]) * t,
                    color1[1] + (color2[1] - color1[1]) * t,
                    color1[2] + (color2[2] - color1[2]) * t
                ];
            }
            
            render() {
                this.ctx.clearRect(0, 0, this.width, this.height);
                
                // Apply random camera drift
                this.camera.rotX += this.cameraDrift.rotX;
                this.camera.rotY += this.cameraDrift.rotY;
                this.camera.rotX = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.camera.rotX));
                
                if (Math.random() < 0.01) {
                    this.cameraDrift.rotX = (Math.random() - 0.5) * 0.001;
                    this.cameraDrift.rotY = (Math.random() - 0.5) * 0.001;
                }
                
                const gridPoints = [];
                const range = 30; // Extended range to reduce cuts
                const step = range / this.gridSize;
                
                let minHeight = Infinity;
                let maxHeight = -Infinity;
                
                // Generate grid points
                for (let i = 0; i <= this.gridSize; i++) {
                    gridPoints[i] = [];
                    for (let j = 0; j <= this.gridSize; j++) {
                        const x = (i - this.gridSize / 2) * step;
                        const z = (j - this.gridSize / 2) * step;
                        const y = this.getWaveHeight(x, z, this.time);
                        
                        minHeight = Math.min(minHeight, y);
                        maxHeight = Math.max(maxHeight, y);
                        
                        gridPoints[i][j] = { x, y, z };
                    }
                }
                
                const faces = [];
                
                for (let i = 0; i < this.gridSize; i++) {
                    for (let j = 0; j < this.gridSize; j++) {
                        const p1 = gridPoints[i][j];
                        const p2 = gridPoints[i + 1][j];
                        const p3 = gridPoints[i][j + 1];
                        const p4 = gridPoints[i + 1][j + 1];
                        
                        faces.push({
                            points: [p1, p2, p3],
                            avgZ: (p1.z + p2.z + p3.z) / 3,
                            avgHeight: (p1.y + p2.y + p3.y) / 3
                        });
                        
                        faces.push({
                            points: [p2, p4, p3],
                            avgZ: (p2.z + p4.z + p3.z) / 3,
                            avgHeight: (p2.y + p4.y + p3.y) / 3
                        });
                    }
                }
                
                faces.sort((a, b) => b.avgZ - a.avgZ);
                
                // Render with Gouraud shading
                faces.forEach(face => {
                    const projectedPoints = face.points.map(p => this.project3D(p.x, p.y, p.z)).filter(p => p !== null);
                    
                    if (projectedPoints.length === 3) {
                        // Calculate colors for each vertex
                        const colors = face.points.map((p, idx) => {
                            const normalizedHeight = (p.y - minHeight) / (maxHeight - minHeight);
                            const color = this.getWaveColor(p.y, p.x, p.z, normalizedHeight, projectedPoints[idx].z);
                            const rgb = color.match(/rgb\((\d+), (\d+), (\d+)\)/);
                            return [parseInt(rgb[1]), parseInt(rgb[2]), parseInt(rgb[3])];
                        });
                        
                        // Create a linear gradient for smooth color interpolation
                        const gradient = this.ctx.createLinearGradient(
                            projectedPoints[0].x, projectedPoints[0].y,
                            projectedPoints[2].x, projectedPoints[2].y
                        );
                        gradient.addColorStop(0, `rgb(${colors[0][0]}, ${colors[0][1]}, ${colors[0][2]})`);
                        gradient.addColorStop(0.5, `rgb(${colors[1][0]}, ${colors[1][1]}, ${colors[1][2]})`);
                        gradient.addColorStop(1, `rgb(${colors[2][0]}, ${colors[2][1]}, ${colors[2][2]})`);
                        
                        this.ctx.fillStyle = gradient;
                        this.ctx.strokeStyle = gradient;
                        this.ctx.lineWidth = 0.2; // Thinner lines for smoother appearance
                        
                        this.ctx.beginPath();
                        this.ctx.moveTo(projectedPoints[0].x, projectedPoints[0].y);
                        this.ctx.lineTo(projectedPoints[1].x, projectedPoints[1].y);
                        this.ctx.lineTo(projectedPoints[2].x, projectedPoints[2].y);
                        this.ctx.closePath();
                        this.ctx.fill();
                        this.ctx.stroke();
                    }
                });
            }
            
            animate() {
                this.time += 0.05;
                this.render();
                requestAnimationFrame(() => this.animate());
            }
        }
        
        window.addEventListener('load', () => {
            new Ocean3D();
        });
    </script>
</body>
</html>