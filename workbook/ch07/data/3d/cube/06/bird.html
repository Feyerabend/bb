<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Ocean with Flying Bird</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #87CEEB 0%, #4682B4 50%, #191970 100%);
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        
        #canvas {
            display: block;
            cursor: grab;
        }
        
        #canvas:active {
            cursor: grabbing;
        }
        
        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0,0,0,0.3);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }
        
        .control-group {
            margin-bottom: 10px;
        }
        
        label {
            display: inline-block;
            width: 120px;
            font-size: 14px;
        }
        
        input[type="range"] {
            width: 100px;
        }
        
        .bird-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            background: rgba(0,0,0,0.3);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }
        
        .flight-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            font-size: 12px;
            background: rgba(0,0,0,0.3);
            padding: 10px;
            border-radius: 5px;
        }
        
        .info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: white;
            font-size: 12px;
            background: rgba(0,0,0,0.3);
            padding: 10px;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div class="controls">
        <div class="control-group">
            <label>Wave Height:</label>
            <input type="range" id="amplitude" min="0.1" max="3" step="0.1" value="1.5">
        </div>
        <div class="control-group">
            <label>Wave Speed:</label>
            <input type="range" id="speed" min="0.1" max="3" step="0.1" value="1">
        </div>
        <div class="control-group">
            <label>Wave Length:</label>
            <input type="range" id="frequency" min="0.1" max="2" step="0.1" value="0.8">
        </div>
        <div class="control-group">
            <label>Complexity:</label>
            <input type="range" id="complexity" min="1" max="4" step="1" value="2">
        </div>
    </div>
    
    <div class="bird-controls">
        <h4 style="margin-top: 0;">Bird Controls</h4>
        <div class="control-group">
            <label>Follow Bird:</label>
            <input type="checkbox" id="followBird" checked>
        </div>
        <div class="control-group">
            <label>Auto Flight:</label>
            <input type="checkbox" id="autoFlight" checked>
        </div>
        <div class="control-group">
            <label>Speed:</label>
            <input type="range" id="birdSpeed" min="0.5" max="3" step="0.1" value="1.5">
        </div>
        <div class="control-group">
            <label>Height:</label>
            <input type="range" id="birdHeight" min="2" max="15" step="0.5" value="8">
        </div>
        <div class="control-group">
            <label>Wing Frequency:</label>
            <input type="range" id="wingFreq" min="0.1" max="1" step="0.05" value="0.3">
        </div>
    </div>
    
    <div class="flight-info">
        <div>Bird Position: <span id="birdPos">0, 0</span></div>
        <div>Altitude: <span id="altitude">0</span>m</div>
        <div>Speed: <span id="flightSpeed">0</span> km/h</div>
        <div>Wing Phase: <span id="wingPhase">0</span>°</div>
    </div>
    
    <div class="info">
        Arrow Keys: Manual Control<br>
        Drag: Rotate View • Scroll: Zoom<br>
        Space: Toggle Auto Flight
    </div>

    <script>
        class Ocean3D {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.width = window.innerWidth;
                this.height = window.innerHeight;
                
                this.canvas.width = this.width;
                this.canvas.height = this.height;
                
                // Camera settings
                this.camera = {
                    x: 0,
                    y: 5,
                    z: -15,
                    rotX: -0.3,
                    rotY: 0,
                    fov: 800
                };
                
                // Bird object with enhanced properties
                this.bird = {
                    x: 0,
                    y: 8,
                    z: 5,
                    velocityX: 0,
                    velocityY: 0,
                    velocityZ: 0,
                    tilt: 0,
                    pitch: 0,
                    roll: 0,
                    wingFlap: 0,
                    wingFrequency: 0.3,
                    size: 1.0,
                    color: [255, 255, 255],
                    speed: 1.5,
                    autoFlight: true,
                    targetX: 0,
                    targetZ: 0,
                    flightPath: 0,
                    glidePhase: 0
                };
                
                // Wave parameters
                this.waveParams = {
                    amplitude: 1.5,
                    frequency: 0.8,
                    speed: 1,
                    complexity: 2
                };
                
                // Procedural generation based on bird position
                this.proceduralSeed = {
                    offsetX: 0,
                    offsetZ: 0,
                    turbulence: 1
                };
                
                this.time = 0;
                this.gridSize = 80;
                this.scale = 0.8;
                this.fogDistance = 30;
                
                // Input handling
                this.keys = {};
                this.mouse = {
                    x: 0,
                    y: 0,
                    isDown: false,
                    lastX: 0,
                    lastY: 0
                };
                
                this.followBird = true;
                
                this.setupEventListeners();
                this.animate();
            }
            
            setupEventListeners() {
                // Mouse controls
                this.canvas.addEventListener('mousedown', (e) => {
                    this.mouse.isDown = true;
                    this.mouse.lastX = e.clientX;
                    this.mouse.lastY = e.clientY;
                });
                
                this.canvas.addEventListener('mousemove', (e) => {
                    if (this.mouse.isDown && !this.followBird) {
                        const deltaX = e.clientX - this.mouse.lastX;
                        const deltaY = e.clientY - this.mouse.lastY;
                        
                        this.camera.rotY += deltaX * 0.01;
                        this.camera.rotX += deltaY * 0.01;
                        
                        this.camera.rotX = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.camera.rotX));
                        
                        this.mouse.lastX = e.clientX;
                        this.mouse.lastY = e.clientY;
                    }
                });
                
                this.canvas.addEventListener('mouseup', () => {
                    this.mouse.isDown = false;
                });
                
                this.canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    if (!this.followBird) {
                        this.camera.z += e.deltaY * 0.01;
                        this.camera.z = Math.max(-50, Math.min(-5, this.camera.z));
                    }
                });
                
                // Keyboard controls
                document.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;
                    if (e.code === 'Space') {
                        e.preventDefault();
                        this.bird.autoFlight = !this.bird.autoFlight;
                        document.getElementById('autoFlight').checked = this.bird.autoFlight;
                    }
                });
                
                document.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                });
                
                // UI controls
                document.getElementById('amplitude').addEventListener('input', (e) => {
                    this.waveParams.amplitude = parseFloat(e.target.value);
                });
                
                document.getElementById('speed').addEventListener('input', (e) => {
                    this.waveParams.speed = parseFloat(e.target.value);
                });
                
                document.getElementById('frequency').addEventListener('input', (e) => {
                    this.waveParams.frequency = parseFloat(e.target.value);
                });
                
                document.getElementById('complexity').addEventListener('input', (e) => {
                    this.waveParams.complexity = parseInt(e.target.value);
                });
                
                document.getElementById('followBird').addEventListener('change', (e) => {
                    this.followBird = e.target.checked;
                });
                
                document.getElementById('autoFlight').addEventListener('change', (e) => {
                    this.bird.autoFlight = e.target.checked;
                });
                
                document.getElementById('birdSpeed').addEventListener('input', (e) => {
                    this.bird.speed = parseFloat(e.target.value);
                });
                
                document.getElementById('birdHeight').addEventListener('input', (e) => {
                    this.bird.y = parseFloat(e.target.value);
                });
                
                document.getElementById('wingFreq').addEventListener('input', (e) => {
                    this.bird.wingFrequency = parseFloat(e.target.value);
                });
                
                window.addEventListener('resize', () => {
                    this.width = window.innerWidth;
                    this.height = window.innerHeight;
                    this.canvas.width = this.width;
                    this.canvas.height = this.height;
                });
            }
            
            updateBird() {
                // Manual controls when not in auto flight
                if (!this.bird.autoFlight) {
                    const acceleration = 0.02;
                    if (this.keys['ArrowUp']) this.bird.velocityZ += acceleration;
                    if (this.keys['ArrowDown']) this.bird.velocityZ -= acceleration;
                    if (this.keys['ArrowLeft']) {
                        this.bird.velocityX -= acceleration;
                        this.bird.roll = Math.max(-0.4, this.bird.roll - 0.03);
                    }
                    if (this.keys['ArrowRight']) {
                        this.bird.velocityX += acceleration;
                        this.bird.roll = Math.min(0.4, this.bird.roll + 0.03);
                    }
                    if (this.keys['KeyW']) this.bird.velocityY += acceleration * 0.5;
                    if (this.keys['KeyS']) this.bird.velocityY -= acceleration * 0.5;
                } else {
                    // Enhanced auto flight pattern with more variety
                    this.bird.flightPath += 0.008;
                    this.bird.glidePhase += 0.012;
                    
                    // Complex flight pattern
                    this.bird.targetX = Math.sin(this.bird.flightPath * 0.7) * 18 + 
                                      Math.cos(this.bird.flightPath * 0.3) * 10 +
                                      Math.sin(this.bird.flightPath * 1.5) * 4;
                    this.bird.targetZ = Math.cos(this.bird.flightPath * 0.5) * 15 + 
                                       Math.sin(this.bird.flightPath * 0.2) * 8 +
                                       Math.cos(this.bird.flightPath * 1.2) * 3;
                    
                    const targetY = 8 + Math.sin(this.bird.flightPath * 1.2) * 4 + 
                                   Math.cos(this.bird.glidePhase * 0.8) * 2;
                    
                    // Smooth movement towards targets with momentum
                    const dx = this.bird.targetX - this.bird.x;
                    const dy = targetY - this.bird.y;
                    const dz = this.bird.targetZ - this.bird.z;
                    
                    this.bird.velocityX += dx * 0.0008;
                    this.bird.velocityY += dy * 0.0006;
                    this.bird.velocityZ += dz * 0.0008;
                    
                    // Banking and pitching in turns
                    this.bird.roll = Math.max(-0.5, Math.min(0.5, dx * 0.08));
                    this.bird.pitch = Math.max(-0.3, Math.min(0.3, -dy * 0.05));
                    this.bird.tilt = this.bird.roll; // Legacy compatibility
                }
                
                // Apply physics with improved drag
                const drag = 0.985;
                this.bird.velocityX *= drag;
                this.bird.velocityY *= drag;
                this.bird.velocityZ *= drag;
                
                // Speed limiting
                const maxSpeed = this.bird.speed * 0.08;
                const speed = Math.sqrt(this.bird.velocityX**2 + this.bird.velocityY**2 + this.bird.velocityZ**2);
                if (speed > maxSpeed) {
                    this.bird.velocityX = (this.bird.velocityX / speed) * maxSpeed;
                    this.bird.velocityY = (this.bird.velocityY / speed) * maxSpeed;
                    this.bird.velocityZ = (this.bird.velocityZ / speed) * maxSpeed;
                }
                
                // Update position
                this.bird.x += this.bird.velocityX;
                this.bird.y += this.bird.velocityY;
                this.bird.z += this.bird.velocityZ;
                
                // Enhanced wing flapping with speed-based frequency
                const flapSpeed = this.bird.wingFrequency + speed * 3;
                this.bird.wingFlap += flapSpeed;
                
                // Smooth roll/pitch decay when not turning
                if (this.bird.autoFlight || (!this.keys['ArrowLeft'] && !this.keys['ArrowRight'])) {
                    this.bird.roll *= 0.92;
                    this.bird.pitch *= 0.95;
                    this.bird.tilt = this.bird.roll; // Keep legacy compatibility
                }
                
                // Update procedural generation based on bird position
                this.proceduralSeed.offsetX = this.bird.x * 0.1;
                this.proceduralSeed.offsetZ = this.bird.z * 0.1;
                this.proceduralSeed.turbulence = 1 + Math.abs(this.bird.velocityX + this.bird.velocityZ) * 5;
                
                // Update camera to follow bird with smoother tracking
                if (this.followBird) {
                    const followDistance = 12;
                    const followHeight = 4;
                    
                    const targetCamX = this.bird.x - Math.sin(this.camera.rotY) * followDistance;
                    const targetCamY = this.bird.y + followHeight;
                    const targetCamZ = this.bird.z - Math.cos(this.camera.rotY) * followDistance;
                    
                    // Smooth camera movement
                    this.camera.x += (targetCamX - this.camera.x) * 0.08;
                    this.camera.y += (targetCamY - this.camera.y) * 0.06;
                    this.camera.z += (targetCamZ - this.camera.z) * 0.08;
                    
                    // Look at bird with smooth rotation
                    const lookAtX = this.bird.x - this.camera.x;
                    const lookAtZ = this.bird.z - this.camera.z;
                    const targetRotY = Math.atan2(lookAtX, lookAtZ);
                    this.camera.rotY += (targetRotY - this.camera.rotY) * 0.04;
                }
                
                // Update UI
                document.getElementById('birdPos').textContent = `${this.bird.x.toFixed(1)}, ${this.bird.z.toFixed(1)}`;
                document.getElementById('altitude').textContent = Math.max(0, this.bird.y - this.getWaveHeight(this.bird.x, this.bird.z, this.time)).toFixed(1);
                document.getElementById('flightSpeed').textContent = (speed * 120).toFixed(0);
                document.getElementById('wingPhase').textContent = ((this.bird.wingFlap % (2 * Math.PI)) * 180 / Math.PI).toFixed(0);
            }
            
            getWaveHeight(x, z, time) {
                let height = 0;
                const complexity = this.waveParams.complexity;
                
                // Add procedural offsets based on bird position
                const procX = x + this.proceduralSeed.offsetX;
                const procZ = z + this.proceduralSeed.offsetZ;
                const turbulence = this.proceduralSeed.turbulence;
                
                // Main waves with procedural variation
                height += Math.sin(procX * this.waveParams.frequency + time * this.waveParams.speed) * this.waveParams.amplitude * 0.7;
                height += Math.sin(procZ * this.waveParams.frequency * 0.7 + time * this.waveParams.speed * 0.8) * this.waveParams.amplitude * 0.6;
                
                if (complexity >= 2) {
                    height += Math.sin(procX * this.waveParams.frequency * 2.3 + procZ * 0.5 + time * this.waveParams.speed * 1.2) * this.waveParams.amplitude * 0.25 * turbulence;
                    height += Math.cos(procZ * this.waveParams.frequency * 1.7 - procX * 0.3 + time * this.waveParams.speed * 0.9) * this.waveParams.amplitude * 0.35;
                }
                
                if (complexity >= 3) {
                    height += Math.sin(procX * this.waveParams.frequency * 4 + time * this.waveParams.speed * 2) * this.waveParams.amplitude * 0.12 * turbulence;
                    height += Math.cos(procZ * this.waveParams.frequency * 3.5 + time * this.waveParams.speed * 1.5) * this.waveParams.amplitude * 0.18;
                }
                
                if (complexity >= 4) {
                    height += Math.sin((procX + procZ) * this.waveParams.frequency * 6 + time * this.waveParams.speed * 3) * this.waveParams.amplitude * 0.07 * turbulence;
                    height += Math.cos((procX - procZ) * this.waveParams.frequency * 5 + time * this.waveParams.speed * 2.5) * this.waveParams.amplitude * 0.09;
                }
                
                return height;
            }
            
            project3D(x, y, z) {
                const cosX = Math.cos(this.camera.rotX);
                const sinX = Math.sin(this.camera.rotX);
                const cosY = Math.cos(this.camera.rotY);
                const sinY = Math.sin(this.camera.rotY);
                
                x -= this.camera.x;
                y -= this.camera.y;
                z -= this.camera.z;
                
                let tempX = x * cosY - z * sinY;
                let tempZ = x * sinY + z * cosY;
                x = tempX;
                z = tempZ;
                
                let tempY = y * cosX - z * sinX;
                tempZ = y * sinX + z * cosX;
                y = tempY;
                z = tempZ;
                
                if (z <= 0) return null;
                
                const scale = this.camera.fov / z;
                return {
                    x: this.width / 2 + x * scale,
                    y: this.height / 2 - y * scale,
                    z: z
                };
            }
            
            getWaveColor(height, x, z, normalizedHeight, depth) {
                const deepBlue = [8, 48, 107];
                const oceanBlue = [13, 94, 175];
                const lightBlue = [52, 152, 219];
                const foam = [220, 240, 255];
                
                let color;
                
                if (normalizedHeight > 0.7) {
                    const t = (normalizedHeight - 0.7) / 0.3;
                    color = [
                        lightBlue[0] + (foam[0] - lightBlue[0]) * t,
                        lightBlue[1] + (foam[1] - lightBlue[1]) * t,
                        lightBlue[2] + (foam[2] - lightBlue[2]) * t
                    ];
                } else if (normalizedHeight > 0.3) {
                    const t = (normalizedHeight - 0.3) / 0.4;
                    color = [
                        oceanBlue[0] + (lightBlue[0] - oceanBlue[0]) * t,
                        oceanBlue[1] + (lightBlue[1] - oceanBlue[1]) * t,
                        oceanBlue[2] + (lightBlue[2] - oceanBlue[2]) * t
                    ];
                } else {
                    const t = normalizedHeight / 0.3;
                    color = [
                        deepBlue[0] + (oceanBlue[0] - deepBlue[0]) * t,
                        deepBlue[1] + (oceanBlue[1] - deepBlue[1]) * t,
                        deepBlue[2] + (oceanBlue[2] - deepBlue[2]) * t
                    ];
                }
                
                const fogFactor = Math.min(1, Math.max(0, (depth - 10) / this.fogDistance));
                const backgroundColor = [71, 130, 180];
                color = [
                    color[0] + (backgroundColor[0] - color[0]) * fogFactor,
                    color[1] + (backgroundColor[1] - color[1]) * fogFactor,
                    color[2] + (backgroundColor[2] - color[2]) * fogFactor
                ];
                
                return `rgb(${Math.round(color[0])}, ${Math.round(color[1])}, ${Math.round(color[2])})`;
            }
            
            // Transform a point with all bird rotations
            transformBirdPoint(point) {
                let { x, y, z } = point;
                
                // Scale by bird size
                x *= this.bird.size;
                y *= this.bird.size;
                z *= this.bird.size;
                
                // Apply pitch (nose up/down)
                const cosPitch = Math.cos(this.bird.pitch);
                const sinPitch = Math.sin(this.bird.pitch);
                let tempY = y * cosPitch - z * sinPitch;
                let tempZ = y * sinPitch + z * cosPitch;
                y = tempY;
                z = tempZ;
                
                // Apply roll (banking left/right)
                const cosRoll = Math.cos(this.bird.roll);
                const sinRoll = Math.sin(this.bird.roll);
                let tempX = x * cosRoll - y * sinRoll;
                tempY = x * sinRoll + y * cosRoll;
                x = tempX;
                y = tempY;
                
                // Translate to bird position
                return {
                    x: x + this.bird.x,
                    y: y + this.bird.y,
                    z: z + this.bird.z
                };
            }
            
            renderBird() {
                const wingFlap = Math.sin(this.bird.wingFlap);
                const wingFlapCos = Math.cos(this.bird.wingFlap);
                
                // Wing rotation based on flapping - wings rotate from the body
                const wingUpAngle = wingFlap * 0.6; // Maximum 34 degrees up/down
                const wingForwardSweep = wingFlapCos * 0.2; // Forward/backward sweep
                
                // Enhanced bird geometry with properly attached wings
                const birdGeometry = [
                    // Main body (fuselage) - elongated and more bird-like
                    {
                        points: [
                            { x: 0, y: 0.1, z: 0.8 },      // nose
                            { x: -0.15, y: -0.05, z: 0.2 }, // left body
                            { x: 0.15, y: -0.05, z: 0.2 }   // right body
                        ],
                        color: [250, 250, 250]
                    },
                    {
                        points: [
                            { x: 0, y: 0.1, z: 0.8 },      // nose
                            { x: 0, y: -0.1, z: 0.2 },     // bottom
                            { x: -0.15, y: -0.05, z: 0.2 } // left body
                        ],
                        color: [245, 245, 245]
                    },
                    {
                        points: [
                            { x: 0, y: 0.1, z: 0.8 },      // nose
                            { x: 0.15, y: -0.05, z: 0.2 }, // right body
                            { x: 0, y: -0.1, z: 0.2 }      // bottom
                        ],
                        color: [245, 245, 245]
                    },
                    
                    // Neck/head connection
                    {
                        points: [
                            { x: 0, y: 0.1, z: 0.8 },
                            { x: 0, y: 0.15, z: 1.0 },
                            { x: 0, y: 0.05, z: 1.0 }
                        ],
                        color: [240, 240, 240]
                    },
                    
                    // Left wing - attached to body, rotating from attachment point
                    {
                        points: [
                            // Wing root (attached to body)
                            { x: -0.15, y: -0.05, z: 0.2 },
                            // Wing tip (moves with flapping)
                            { 
                                x: -0.15 - 1.2 * Math.cos(wingUpAngle) + wingForwardSweep * 0.3, 
                                y: -0.05 + 1.2 * Math.sin(wingUpAngle), 
                                z: 0.1 + wingForwardSweep 
                            },
                            // Wing trailing edge
                            { 
                                x: -0.15 - 0.8 * Math.cos(wingUpAngle) + wingForwardSweep * 0.2, 
                                y: -0.05 + 0.8 * Math.sin(wingUpAngle), 
                                z: -0.1 + wingForwardSweep * 0.5 
                            }
                        ],
                        color: [230, 230, 235]
                    },
                    
                    // Right wing - attached to body, rotating from attachment point
                    {
                        points: [
                            // Wing root (attached to body)
                            { x: 0.15, y: -0.05, z: 0.2 },
                            // Wing tip (moves with flapping)
                            { 
                                x: 0.15 + 1.2 * Math.cos(wingUpAngle) - wingForwardSweep * 0.3, 
                                y: -0.05 + 1.2 * Math.sin(wingUpAngle), 
                                z: 0.1 + wingForwardSweep 
                            },
                            // Wing trailing edge
                            { 
                                x: 0.15 + 0.8 * Math.cos(wingUpAngle) - wingForwardSweep * 0.2, 
                                y: -0.05 + 0.8 * Math.sin(wingUpAngle), 
                                z: -0.1 + wingForwardSweep * 0.5 
                            }
                        ],
                        color: [230, 230, 235]
                    },
                    
                    // Wing connecting segments (more realistic attachment)
                    {
                        points: [
                            { x: -0.15, y: -0.05, z: 0.2 },
                            { x: -0.25, y: -0.02, z: 0.15 },
                            { x: -0.2, y: -0.08, z: 0.0 }
                        ],
                        color: [235, 235, 240]
                    },
                    {
                        points: [
                            { x: 0.15, y: -0.05, z: 0.2 },
                            { x: 0.25, y: -0.02, z: 0.15 },
                            { x: 0.2, y: -0.08, z: 0.0 }
                        ],
                        color: [235, 235, 240]
                    },
                    
                    // Tail - more detailed
                    {
                        points: [
                            { x: 0, y: -0.1, z: 0.2 },
                            { x: 0, y: 0.05, z: -0.6 },
                            { x: -0.1, y: 0, z: -0.4 }
                        ],
                        color: [240, 240, 240]
                    },
                    {
                        points: [
                            { x: 0, y: -0.1, z: 0.2 },
                            { x: 0.1, y: 0, z: -0.4 },
                            { x: 0, y: 0.05, z: -0.6 }
                        ],
                        color: [240, 240, 240]
                    }
                ];
                
                // Transform and render each triangle
                const triangles = [];
                
                for (const triangle of birdGeometry) {
                    const transformedPoints = triangle.points.map(point => 
                        this.transformBirdPoint(point)
                    );
                    
                    const projectedPoints = transformedPoints.map(point => 
                        this.project3D(point.x, point.y, point.z)
                    ).filter(point => point !== null);
                    
                    if (projectedPoints.length === 3) {
                        // Calculate depth for z-sorting
                        const avgZ = transformedPoints.reduce((sum, p) => sum + p.z, 0) / 3;
                        
                        triangles.push({
                            points: projectedPoints,
                            color: triangle.color,
                            depth: avgZ
                        });
                    }
                }
                
                // Sort triangles by depth (back to front for proper alpha blending)
                triangles.sort((a, b) => b.depth - a.depth);
                
                // Render triangles
                for (const triangle of triangles) {
                    this.ctx.fillStyle = `rgb(${triangle.color[0]}, ${triangle.color[1]}, ${triangle.color[2]})`;
                    this.ctx.strokeStyle = `rgb(${Math.max(0, triangle.color[0] - 30)}, ${Math.max(0, triangle.color[1] - 30)}, ${Math.max(0, triangle.color[2] - 30)})`;
                    this.ctx.lineWidth = 1;
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(triangle.points[0].x, triangle.points[0].y);
                    this.ctx.lineTo(triangle.points[1].x, triangle.points[1].y);
                    this.ctx.lineTo(triangle.points[2].x, triangle.points[2].y);
                    this.ctx.closePath();
                    this.ctx.fill();
                    this.ctx.stroke();
                }
            }
            
            render() {
                this.ctx.clearRect(0, 0, this.width, this.height);
                
                // Create ocean surface
                const points = [];
                const step = this.gridSize / 20;
                
                // Generate grid around bird position for infinite ocean effect
                const startX = Math.floor(this.bird.x / step) * step - this.gridSize / 2;
                const startZ = Math.floor(this.bird.z / step) * step - this.gridSize / 2;
                
                for (let i = 0; i <= 20; i++) {
                    points[i] = [];
                    for (let j = 0; j <= 20; j++) {
                        const x = startX + i * step;
                        const z = startZ + j * step;
                        const y = this.getWaveHeight(x, z, this.time);
                        
                        const projected = this.project3D(x, y, z);
                        if (projected) {
                            points[i][j] = {
                                ...projected,
                                worldY: y
                            };
                        } else {
                            points[i][j] = null;
                        }
                    }
                }
                
                // Render ocean triangles
                for (let i = 0; i < 20; i++) {
                    for (let j = 0; j < 20; j++) {
                        const p1 = points[i][j];
                        const p2 = points[i + 1][j];
                        const p3 = points[i][j + 1];
                        const p4 = points[i + 1][j + 1];
                        
                        if (p1 && p2 && p3 && p4) {
                            const avgHeight = (p1.worldY + p2.worldY + p3.worldY + p4.worldY) / 4;
                            const normalizedHeight = (avgHeight + this.waveParams.amplitude * 2) / (this.waveParams.amplitude * 4);
                            const avgDepth = (p1.z + p2.z + p3.z + p4.z) / 4;
                            
                            const x = startX + i * step;
                            const z = startZ + j * step;
                            const color = this.getWaveColor(avgHeight, x, z, normalizedHeight, avgDepth);
                            
                            this.ctx.fillStyle = color;
                            this.ctx.strokeStyle = color;
                            
                            // Draw two triangles to form a quad
                            this.ctx.beginPath();
                            this.ctx.moveTo(p1.x, p1.y);
                            this.ctx.lineTo(p2.x, p2.y);
                            this.ctx.lineTo(p3.x, p3.y);
                            this.ctx.closePath();
                            this.ctx.fill();
                            
                            this.ctx.beginPath();
                            this.ctx.moveTo(p2.x, p2.y);
                            this.ctx.lineTo(p4.x, p4.y);
                            this.ctx.lineTo(p3.x, p3.y);
                            this.ctx.closePath();
                            this.ctx.fill();
                        }
                    }
                }
                
                // Render bird
                this.renderBird();
                
                // Add atmospheric effects
                this.renderAtmosphere();
            }
            
            renderAtmosphere() {
                // Add subtle vignette effect
                const gradient = this.ctx.createRadialGradient(
                    this.width / 2, this.height / 2, 0,
                    this.width / 2, this.height / 2, Math.max(this.width, this.height) / 2
                );
                gradient.addColorStop(0, 'rgba(0,0,0,0)');
                gradient.addColorStop(1, 'rgba(0,0,0,0.1)');
                
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.width, this.height);
                
                // Add horizon line
                const horizonY = this.height / 2 + Math.sin(this.camera.rotX) * 200;
                if (horizonY > 0 && horizonY < this.height) {
                    this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                    this.ctx.lineWidth = 1;
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, horizonY);
                    this.ctx.lineTo(this.width, horizonY);
                    this.ctx.stroke();
                }
            }
            
            animate() {
                this.time += 0.02;
                this.updateBird();
                this.render();
                requestAnimationFrame(() => this.animate());
            }
        }
        
        // Initialize the ocean scene
        const ocean = new Ocean3D();
    </script>
</body>
</html>